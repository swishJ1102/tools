import com.github.javaparser.*;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.ast.visitor.VoidVisitorAdapter;

import java.io.File;
import java.io.FileInputStream;
import java.util.*;

public class MethodCallAnalyzer {
    private static final Map<String, Set<String>> callGraph = new HashMap<>();

    public static void main(String[] args) throws Exception {
        String projectPath = "your/project/path";  // 替换为你的工程路径
        File projectDir = new File(projectPath);
        analyzeProject(projectDir);

        // 输出调用关系
        callGraph.forEach((caller, callees) -> {
            System.out.println(caller + " calls: " + callees);
        });
    }

    private static void analyzeProject(File projectDir) throws Exception {
        for (File file : Objects.requireNonNull(projectDir.listFiles())) {
            if (file.isDirectory()) {
                analyzeProject(file); // 递归遍历子目录
            } else if (file.getName().endsWith(".java")) {
                analyzeFile(file);
            }
        }
    }

    private static void analyzeFile(File file) throws Exception {
        FileInputStream fis = new FileInputStream(file);
        CompilationUnit cu = StaticJavaParser.parse(fis);

        // 遍历方法定义
        cu.findAll(MethodDeclaration.class).forEach(method -> {
            String className = cu.getPrimaryTypeName().orElse("UnknownClass");
            String methodName = method.getNameAsString();
            String fullMethodName = className + "." + methodName;

            // 提取方法调用
            method.accept(new MethodCallCollector(), fullMethodName);
        });

        fis.close();
    }

    // 访问者模式：收集方法调用
    private static class MethodCallCollector extends VoidVisitorAdapter<String> {
        @Override
        public void visit(MethodCallExpr methodCall, String callerMethodName) {
            super.visit(methodCall, callerMethodName);

            String calledMethod = methodCall.getNameAsString();
            callGraph.computeIfAbsent(callerMethodName, k -> new HashSet<>()).add(calledMethod);
        }
    }
}
