import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.FieldDeclaration;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.body.VariableDeclarator;
import com.github.javaparser.ast.expr.*;
import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;
import com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;
import com.github.javaparser.symbolsolver.JavaSymbolSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;

import java.io.*;
import java.util.*;

public class MethodCallAnalyzer {
    private static final Map<String, Set<String>> callGraph = new HashMap<>();
    private static final String OUTPUT_FILE = "call_graph.txt";
    private static CombinedTypeSolver typeSolver;
    private static final String PROJECT_PACKAGE_PREFIX = "com.myproject"; // 工程包名前缀

    public static void main(String[] args) throws IOException {
        File srcRoot = new File("your/project/src/main/java"); // 设置源码根目录

        // 初始化解析器
        typeSolver = new CombinedTypeSolver();
        typeSolver.add(new ReflectionTypeSolver()); // 解析 JDK 方法
        typeSolver.add(new JavaParserTypeSolver(srcRoot)); // 解析工程源码
        StaticJavaParser.getConfiguration().setSymbolResolver(new JavaSymbolSolver(typeSolver));

        // 遍历源码目录
        analyzeProject(srcRoot);

        // 写入调用关系
        writeResults();
    }

    private static void analyzeProject(File directory) {
        for (File file : Objects.requireNonNull(directory.listFiles())) {
            if (file.isDirectory()) {
                analyzeProject(file);
            } else if (file.getName().endsWith(".java")) {
                analyzeFile(file);
            }
        }
    }

    private static void analyzeFile(File file) {
        try (FileInputStream fis = new FileInputStream(file)) {
            CompilationUnit cu = StaticJavaParser.parse(fis);

            // 解析字段定义（包括 @Autowired）
            Map<String, String> fieldTypeMap = new HashMap<>();
            cu.findAll(FieldDeclaration.class).forEach(field -> processFieldDeclaration(field, fieldTypeMap));

            // 解析方法调用
            cu.findAll(MethodDeclaration.class).forEach(methodDeclaration -> {
                try {
                    String callerSignature = methodDeclaration.resolve().getQualifiedSignature();
                    methodDeclaration.findAll(MethodCallExpr.class).forEach(methodCall -> processMethodCall(callerSignature, methodCall, fieldTypeMap));
                } catch (Exception e) {
                    System.err.println("无法解析方法：" + methodDeclaration.getNameAsString());
                }
            });
        } catch (Exception e) {
            System.err.println("无法解析文件：" + file.getAbsolutePath());
        }
    }

    /**
     * 解析字段声明，支持 @Autowired/@Resource 注入
     */
    private static void processFieldDeclaration(FieldDeclaration field, Map<String, String> fieldTypeMap) {
        for (VariableDeclarator var : field.getVariables()) {
            String varName = var.getNameAsString();
            try {
                String varType = var.getType().resolve().describe();
                fieldTypeMap.put(varName, varType);
            } catch (Exception e) {
                System.err.println("无法解析字段：" + varName);
            }
        }
    }

    /**
     * 解析方法调用，并存储调用关系
     */
    private static void processMethodCall(String callerSignature, MethodCallExpr methodCall, Map<String, String> fieldTypeMap) {
        try {
            ResolvedMethodDeclaration resolvedMethod = methodCall.resolve();
            ResolvedReferenceTypeDeclaration declaringType = resolvedMethod.declaringType();

            // 过滤 JDK 和第三方库
            if (!declaringType.getQualifiedName().startsWith(PROJECT_PACKAGE_PREFIX)) {
                return;
            }

            String calleeSignature = resolvedMethod.getQualifiedSignature();

            // 处理实例调用
            if (methodCall.getScope().isPresent()) {
                Expression scope = methodCall.getScope().get();
                if (scope.isNameExpr()) {
                    String varName = scope.asNameExpr().getNameAsString();
                    if (fieldTypeMap.containsKey(varName)) {
                        String inferredClass = fieldTypeMap.get(varName);
                        calleeSignature = inferredClass + "." + resolvedMethod.getSignature();
                    }
                }
            }

            // 存储调用关系
            callGraph.computeIfAbsent(callerSignature, k -> new HashSet<>()).add(calleeSignature);
        } catch (Exception e) {
            System.err.println("解析失败：" + methodCall);
        }
    }

    /**
     * 将调用关系写入文件
     */
    private static void writeResults() {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(OUTPUT_FILE))) {
            for (Map.Entry<String, Set<String>> entry : callGraph.entrySet()) {
                writer.write(entry.getKey() + "\n");
                for (String callee : entry.getValue()) {
                    writer.write("    → " + callee + "\n");
                }
            }
            System.out.println("调用关系已写入：" + OUTPUT_FILE);
        } catch (IOException e) {
            System.err.println("写入文件失败：" + e.getMessage());
        }
    }
}

import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.symbolsolver.JavaSymbolSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;
import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;
import com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;

import java.io.*;
import java.util.*;

public class CallGraphAnalyzer {

    // 存储调用关系：caller 方法 -> 被调用方法集合
    private static final Map<String, Set<String>> callGraph = new HashMap<>();
    // 请替换为你工程内部的包名前缀，比如 "com.myproject"
    private static final String projectPackagePrefix = "com.myproject";
    private static final String OUTPUT_FILE = "call_graph.txt";
    private static CombinedTypeSolver combinedTypeSolver;

    public static void main(String[] args) throws Exception {
        File srcDir = new File("your/project/src"); // 请确保这是你的源码根目录（包的起点）
        System.out.println("解析源码路径: " + srcDir.getAbsolutePath());

        // 初始化 TypeSolver，确保能解析整个项目
        combinedTypeSolver = new CombinedTypeSolver();
        combinedTypeSolver.add(new ReflectionTypeSolver(false)); // 解析 JDK 内部的类
        combinedTypeSolver.add(new JavaParserTypeSolver(srcDir));  // 解析项目源码

        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(combinedTypeSolver);
        StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);

        System.out.println("开始解析工程...");
        traverseDirectory(srcDir);
        System.out.println("解析完成，正在写入调用关系...");

        writeCallChainsToFile();
        System.out.println("调用关系已写入文件: " + OUTPUT_FILE);
    }

    // 遍历目录下所有 .java 文件
    private static void traverseDirectory(File directory) throws Exception {
        for (File file : Objects.requireNonNull(directory.listFiles())) {
            if (file.isDirectory()) {
                traverseDirectory(file);
            } else if (file.getName().endsWith(".java")) {
                processFile(file);
            }
        }
    }

    // 解析单个 Java 文件，提取方法调用关系
    private static void processFile(File file) {
        System.out.println("解析文件: " + file.getName());
        try (FileInputStream fis = new FileInputStream(file)) {
            CompilationUnit cu = StaticJavaParser.parse(fis);
            cu.findAll(MethodDeclaration.class).forEach(methodDeclaration -> {
                try {
                    String callerSignature = methodDeclaration.resolve().getQualifiedSignature();
                    methodDeclaration.findAll(MethodCallExpr.class).forEach(methodCall -> {
                        // 使用 tryResolve 包装解析过程
                        Optional<ResolvedMethodDeclaration> opt = tryResolve(methodCall);
                        if (opt.isPresent()) {
                            ResolvedMethodDeclaration resolvedCallee = opt.get();
                            // 获取被调用方法所在的类
                            ResolvedReferenceTypeDeclaration declaringType = resolvedCallee.declaringType();
                            String declaringTypeName = declaringType.getQualifiedName();
                            // 过滤掉非项目内部的调用（例如 JDK 或第三方库）
                            if (!declaringTypeName.startsWith(projectPackagePrefix)) {
                                return;
                            }
                            String calleeSignature = resolvedCallee.getQualifiedSignature();
                            callGraph.computeIfAbsent(callerSignature, k -> new HashSet<>()).add(calleeSignature);
                            System.out.println("解析成功: " + callerSignature + " 调用了 " + calleeSignature);
                        }
                    });
                } catch (Exception e) {
                    System.err.println("解析方法声明失败: " + methodDeclaration.getNameAsString() + " - " + e.getMessage());
                }
            });
        } catch (Exception e) {
            System.err.println("处理文件失败: " + file.getAbsolutePath() + " - " + e.getMessage());
        }
    }

    /**
     * 尝试解析 MethodCallExpr，如果解析成功则返回 Optional 包装的 ResolvedMethodDeclaration，
     * 否则返回 Optional.empty()。
     */
    private static Optional<ResolvedMethodDeclaration> tryResolve(MethodCallExpr methodCall) {
        try {
            return Optional.of(methodCall.resolve());
        } catch (Exception e) {
            System.err.println("解析方法调用失败: " + methodCall + " - " + e.getMessage());
            return Optional.empty();
        }
    }

    // 将调用关系写入文件
    private static void writeCallChainsToFile() {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(OUTPUT_FILE))) {
            // 简单写出每个调用者与对应的被调用者
            for (String caller : callGraph.keySet()) {
                writer.write(caller + "\n");
                for (String callee : callGraph.get(caller)) {
                    writer.write("    → " + callee + "\n");
                }
            }
        } catch (IOException e) {
            System.err.println("写入文件失败: " + e.getMessage());
        }
    }
}




import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.symbolsolver.JavaSymbolSolver;
import com.github.javaparser.symbolsolver.model.resolution.SymbolReference;
import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;
import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;
import com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;

import java.io.*;
import java.util.*;

public class CallGraphAnalyzer {
    private static final Map<String, Set<String>> callGraph = new HashMap<>();
    private static final String projectPackagePrefix = "com.myproject"; // 你的工程包名
    private static final String OUTPUT_FILE = "call_graph.txt"; // 输出文件路径
    private static CombinedTypeSolver combinedTypeSolver;

    public static void main(String[] args) throws Exception {
        File srcDir = new File("your/project/src"); // **确保这是你的 src 目录**
        System.out.println("✅ JavaParserTypeSolver 解析路径: " + srcDir.getAbsolutePath());

        combinedTypeSolver = new CombinedTypeSolver();
        combinedTypeSolver.add(new ReflectionTypeSolver(false)); // 解析 JDK 类
        combinedTypeSolver.add(new JavaParserTypeSolver(srcDir)); // 解析 Java 源码

        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(combinedTypeSolver);
        StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);

        System.out.println("🔍 开始解析工程...");
        traverseDirectory(srcDir);
        System.out.println("✅ 解析完成！正在写入调用关系...");

        writeCallChainsToFile();
        System.out.println("📄 调用关系已写入: " + OUTPUT_FILE);
    }

    private static void traverseDirectory(File directory) throws Exception {
        for (File file : Objects.requireNonNull(directory.listFiles())) {
            if (file.isDirectory()) {
                traverseDirectory(file);
            } else if (file.getName().endsWith(".java")) {
                processFile(file);
            }
        }
    }

    private static void processFile(File file) {
        System.out.println("📂 正在解析文件: " + file.getName());
        try (FileInputStream fis = new FileInputStream(file)) {
            CompilationUnit cu = StaticJavaParser.parse(fis);
            cu.findAll(MethodDeclaration.class).forEach(methodDeclaration -> {
                try {
                    String callerSignature = methodDeclaration.resolve().getQualifiedSignature();

                    methodDeclaration.findAll(MethodCallExpr.class).forEach(methodCall -> {
                        try {
                            System.out.println("🔍 AST 方法调用: " + methodCall);
                            System.out.println("🔍 方法所属类: " + methodCall.getScope().orElse(null));

                            SymbolReference<ResolvedMethodDeclaration> ref = combinedTypeSolver.tryToSolveMethod(
                                    "com.myproject.B", "methodX"
                            );
                            if (!ref.isSolved()) {
                                System.err.println("⚠️ `methodX()` 解析失败，跳过");
                                return;
                            }

                            ResolvedMethodDeclaration resolvedCallee = methodCall.resolve();
                            ResolvedReferenceTypeDeclaration declaringType = resolvedCallee.declaringType();
                            String declaringTypeName = declaringType.getQualifiedName();

                            if (!declaringTypeName.startsWith(projectPackagePrefix)) {
                                return;
                            }

                            String calleeSignature = resolvedCallee.getQualifiedSignature();
                            callGraph.computeIfAbsent(callerSignature, k -> new HashSet<>()).add(calleeSignature);

                            System.out.println("🔗 " + callerSignature + " 调用了 " + calleeSignature);
                        } catch (Exception e) {
                            System.err.println("⚠️ 方法解析失败: " + methodCall + " - " + e.getMessage());
                        }
                    });
                } catch (Exception e) {
                    System.err.println("❌ 方法声明解析失败: " + methodDeclaration.getNameAsString() + " - " + e.getMessage());
                }
            });
        } catch (Exception e) {
            System.err.println("❌ 处理失败: " + file.getAbsolutePath() + " - " + e.getMessage());
        }
    }

    private static void writeCallChainsToFile() {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(OUTPUT_FILE))) {
            for (String caller : callGraph.keySet()) {
                writer.write(caller + "\n");
                for (String callee : callGraph.get(caller)) {
                    writer.write("    → " + callee + "\n");
                }
            }
            System.out.println("✅ 调用关系已成功写入: " + OUTPUT_FILE);
        } catch (IOException e) {
            System.err.println("❌ 写入文件失败: " + e.getMessage());
        }
    }
}


import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.symbolsolver.JavaSymbolSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;
import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;
import com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;

import java.io.*;
import java.util.*;

public class CallGraphAnalyzer {

    private static final Map<String, Set<String>> callGraph = new HashMap<>();
    private static final String projectPackagePrefix = "com.myproject"; // 你的工程包名
    private static final String OUTPUT_FILE = "call_graph.txt"; // 输出文件路径
    private static CombinedTypeSolver combinedTypeSolver;

    public static void main(String[] args) throws Exception {
        File srcDir = new File("your/project/src"); // **确保这是你的 src 目录**

        // **确保 TypeSolver 解析整个项目**
        combinedTypeSolver = new CombinedTypeSolver();
        combinedTypeSolver.add(new ReflectionTypeSolver()); // 解析 JDK 类
        combinedTypeSolver.add(new JavaParserTypeSolver(srcDir)); // 解析 Java 源码

        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(combinedTypeSolver);
        StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);

        System.out.println("解析开始...");
        traverseDirectory(srcDir);
        System.out.println("解析完成！正在写入文件...");

        writeCallChainsToFile();
        System.out.println("调用关系已写入: " + OUTPUT_FILE);
    }

    // 遍历整个 Java 目录
    private static void traverseDirectory(File directory) throws Exception {
        for (File file : Objects.requireNonNull(directory.listFiles())) {
            if (file.isDirectory()) {
                traverseDirectory(file);
            } else if (file.getName().endsWith(".java")) {
                processFile(file);
            }
        }
    }

    // 解析 Java 文件，提取方法调用关系
    private static void processFile(File file) {
        System.out.println("正在解析文件: " + file.getName());
        try (FileInputStream fis = new FileInputStream(file)) {
            CompilationUnit cu = StaticJavaParser.parse(fis);
            cu.findAll(MethodDeclaration.class).forEach(methodDeclaration -> {
                try {
                    String callerSignature = methodDeclaration.resolve().getQualifiedSignature();

                    methodDeclaration.findAll(MethodCallExpr.class).forEach(methodCall -> {
                        try {
                            ResolvedMethodDeclaration resolvedCallee = methodCall.resolve();
                            ResolvedReferenceTypeDeclaration declaringType = resolvedCallee.declaringType();
                            String declaringTypeName = declaringType.getQualifiedName();

                            // **只解析工程内部的方法调用**
                            if (!declaringTypeName.startsWith(projectPackagePrefix)) {
                                return;
                            }

                            String calleeSignature = resolvedCallee.getQualifiedSignature();
                            callGraph.computeIfAbsent(callerSignature, k -> new HashSet<>()).add(calleeSignature);

                            System.out.println("✅ " + callerSignature + " 调用了 " + calleeSignature);
                        } catch (Exception e) {
                            System.err.println("❌ 方法解析失败: " + methodCall + " - " + e.getMessage());
                        }
                    });
                } catch (Exception e) {
                    System.err.println("❌ 方法声明解析失败: " + methodDeclaration.getNameAsString() + " - " + e.getMessage());
                }
            });
        } catch (Exception e) {
            System.err.println("❌ 处理失败: " + file.getAbsolutePath() + " - " + e.getMessage());
        }
    }

    // 写入调用链到文件
    private static void writeCallChainsToFile() {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(OUTPUT_FILE))) {
            for (String caller : callGraph.keySet()) {
                writer.write(caller + "\n");
                for (String callee : callGraph.get(caller)) {
                    writer.write("    → " + callee + "\n");
                }
            }
            System.out.println("✅ 调用关系已成功写入: " + OUTPUT_FILE);
        } catch (IOException e) {
            System.err.println("❌ 写入文件失败: " + e.getMessage());
        }
    }
}




import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.symbolsolver.JavaSymbolSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;
import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;
import com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;

import java.io.*;
import java.util.*;

public class CallGraphAnalyzer {

    private static final Map<String, Set<String>> callGraph = new HashMap<>();
    private static final String projectPackagePrefix = "com.myproject"; // 替换成你的包名
    private static final String OUTPUT_FILE = "call_graph.txt"; // 输出文件路径
    private static CombinedTypeSolver combinedTypeSolver;

    public static void main(String[] args) throws Exception {
        File srcDir = new File("your/project/src"); // 你的 Java 源码目录

        // 初始化 TypeSolver，确保可以解析整个项目代码
        combinedTypeSolver = new CombinedTypeSolver();
        combinedTypeSolver.add(new ReflectionTypeSolver()); // 解析 JDK 类
        combinedTypeSolver.add(new JavaParserTypeSolver(srcDir)); // 解析 Java 源码

        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(combinedTypeSolver);
        StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);

        // 解析整个工程的调用关系
        traverseDirectory(srcDir);

        // 将调用关系写入文件
        writeCallChainsToFile();
    }

    // 遍历所有 Java 文件
    private static void traverseDirectory(File directory) throws Exception {
        for (File file : Objects.requireNonNull(directory.listFiles())) {
            if (file.isDirectory()) {
                traverseDirectory(file);
            } else if (file.getName().endsWith(".java")) {
                processFile(file);
            }
        }
    }

    // 解析 Java 文件，提取方法调用关系
    private static void processFile(File file) {
        try (FileInputStream fis = new FileInputStream(file)) {
            CompilationUnit cu = StaticJavaParser.parse(fis);
            cu.findAll(MethodDeclaration.class).forEach(methodDeclaration -> {
                try {
                    String callerSignature = methodDeclaration.resolve().getQualifiedSignature();

                    // 解析方法体内所有方法调用
                    methodDeclaration.findAll(MethodCallExpr.class).forEach(methodCall -> {
                        try {
                            ResolvedMethodDeclaration resolvedCallee = methodCall.resolve();
                            ResolvedReferenceTypeDeclaration declaringType = resolvedCallee.declaringType();
                            String declaringTypeName = declaringType.getQualifiedName();

                            // 过滤非工程内部的方法
                            if (!declaringTypeName.startsWith(projectPackagePrefix)) {
                                return;
                            }

                            String calleeSignature = resolvedCallee.getQualifiedSignature();
                            callGraph.computeIfAbsent(callerSignature, k -> new HashSet<>()).add(calleeSignature);
                        } catch (Exception e) {
                            System.err.println("解析失败: " + methodCall + " - " + e.getMessage());
                        }
                    });
                } catch (Exception e) {
                    System.err.println("解析失败: " + methodDeclaration.getNameAsString() + " - " + e.getMessage());
                }
            });
        } catch (Exception e) {
            System.err.println("处理失败: " + file.getAbsolutePath() + " - " + e.getMessage());
        }
    }

    // 写入调用链到文件
    private static void writeCallChainsToFile() {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(OUTPUT_FILE))) {
            Set<String> allCallers = new HashSet<>(callGraph.keySet());
            Set<String> allCallees = new HashSet<>();
            for (Set<String> callees : callGraph.values()) {
                allCallees.addAll(callees);
            }

            // 找到根节点（只作为调用者，不是被调用者）
            Set<String> roots = new HashSet<>(allCallers);
            roots.removeAll(allCallees);

            if (roots.isEmpty()) {
                roots = allCallers; // 可能所有方法都有相互调用
            }

            for (String root : roots) {
                writeChain(writer, root, new HashSet<>(), 0);
            }

            System.out.println("调用关系已写入: " + OUTPUT_FILE);
        } catch (IOException e) {
            System.err.println("写入文件失败: " + e.getMessage());
        }
    }

    // 递归写入调用链
    private static void writeChain(BufferedWriter writer, String method, Set<String> visited, int depth) throws IOException {
        for (int i = 0; i < depth; i++) {
            writer.write("    ");
        }
        writer.write(method + "\n");

        if (visited.contains(method)) {
            return;
        }
        visited.add(method);

        Set<String> callees = callGraph.get(method);
        if (callees != null) {
            for (String callee : callees) {
                writeChain(writer, callee, new HashSet<>(visited), depth + 1);
            }
        }
    }
}





import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.symbolsolver.JavaSymbolSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;
import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;
import com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;

import java.io.*;
import java.util.*;

public class CallGraphAnalyzer {

    // 存储调用关系：caller 方法 -> 被调用方法集合
    private static final Map<String, Set<String>> callGraph = new HashMap<>();
    private static final String projectPackagePrefix = "com.myproject"; // 请修改为你工程的包名
    private static final String OUTPUT_FILE = "call_graph.txt"; // 输出文件路径

    public static void main(String[] args) throws Exception {
        File srcDir = new File("your/project/src"); // 替换成你的源码路径

        CombinedTypeSolver combinedTypeSolver = new CombinedTypeSolver();
        combinedTypeSolver.add(new ReflectionTypeSolver()); // 解析 JDK
        combinedTypeSolver.add(new JavaParserTypeSolver(srcDir)); // 解析 Java 源码

        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(combinedTypeSolver);
        StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);

        // 遍历整个工程的 .java 文件，解析方法调用关系
        traverseDirectory(srcDir);

        // 将调用链写入文件
        writeCallChainsToFile();
    }

    // 遍历所有 Java 文件
    private static void traverseDirectory(File directory) throws Exception {
        for (File file : Objects.requireNonNull(directory.listFiles())) {
            if (file.isDirectory()) {
                traverseDirectory(file);
            } else if (file.getName().endsWith(".java")) {
                processFile(file);
            }
        }
    }

    // 解析单个 Java 文件，提取方法调用关系
    private static void processFile(File file) {
        try (FileInputStream fis = new FileInputStream(file)) {
            CompilationUnit cu = StaticJavaParser.parse(fis);
            cu.findAll(MethodDeclaration.class).forEach(methodDeclaration -> {
                try {
                    String callerSignature = methodDeclaration.resolve().getQualifiedSignature();
                    methodDeclaration.findAll(MethodCallExpr.class).forEach(methodCall -> {
                        try {
                            ResolvedMethodDeclaration resolvedCallee = methodCall.resolve();
                            ResolvedReferenceTypeDeclaration declaringType = resolvedCallee.declaringType();
                            String declaringTypeName = declaringType.getQualifiedName();

                            // 只解析工程内部的方法调用
                            if (!declaringTypeName.startsWith(projectPackagePrefix)) {
                                return;
                            }

                            String calleeSignature = resolvedCallee.getQualifiedSignature();
                            callGraph.computeIfAbsent(callerSignature, k -> new HashSet<>()).add(calleeSignature);
                        } catch (Exception e) {
                            System.err.println("无法解析调用: " + methodCall + " - " + e.getMessage());
                        }
                    });
                } catch (Exception e) {
                    System.err.println("无法解析方法声明: " + methodDeclaration.getNameAsString() + " - " + e.getMessage());
                }
            });
        } catch (Exception e) {
            System.err.println("处理文件失败: " + file.getAbsolutePath() + " - " + e.getMessage());
        }
    }

    // 写入调用链到文件
    private static void writeCallChainsToFile() {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(OUTPUT_FILE))) {
            Set<String> allCallers = new HashSet<>(callGraph.keySet());
            Set<String> allCallees = new HashSet<>();
            for (Set<String> callees : callGraph.values()) {
                allCallees.addAll(callees);
            }

            // 根节点：方法出现在调用者，但不在被调用者中
            Set<String> roots = new HashSet<>(allCallers);
            roots.removeAll(allCallees);

            if (roots.isEmpty()) {
                roots = allCallers; // 可能所有方法都有相互调用关系
            }

            for (String root : roots) {
                writeChain(writer, root, new HashSet<>(), 0);
            }

            System.out.println("调用关系已写入: " + OUTPUT_FILE);
        } catch (IOException e) {
            System.err.println("写入文件失败: " + e.getMessage());
        }
    }

    // 递归写入调用链
    private static void writeChain(BufferedWriter writer, String method, Set<String> visited, int depth) throws IOException {
        // 处理缩进
        for (int i = 0; i < depth; i++) {
            writer.write("    ");
        }
        writer.write(method + "\n");

        // 避免无限循环
        if (visited.contains(method)) {
            return;
        }
        visited.add(method);

        Set<String> callees = callGraph.get(method);
        if (callees != null) {
            for (String callee : callees) {
                writeChain(writer, callee, new HashSet<>(visited), depth + 1);
            }
        }
    }
}







import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.symbolsolver.JavaSymbolSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;
import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;
import com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;

import java.io.File;
import java.io.FileInputStream;
import java.util.*;

public class CallGraphAnalyzer {

    // 保存调用关系：caller方法的全限定签名 -> set(被调用方法的全限定签名)
    private static final Map<String, Set<String>> callGraph = new HashMap<>();
    // 请修改为你工程内代码的包名前缀，如 "com.myproject"；不符合条件的调用会被过滤掉
    private static final String projectPackagePrefix = "com.myproject";

    public static void main(String[] args) throws Exception {
        // 设定源码目录，替换为你实际的源码路径
        File srcDir = new File("your/project/src");
        CombinedTypeSolver combinedTypeSolver = new CombinedTypeSolver();
        combinedTypeSolver.add(new ReflectionTypeSolver());
        combinedTypeSolver.add(new JavaParserTypeSolver(srcDir));

        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(combinedTypeSolver);
        StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);

        // 遍历整个工程的 .java 文件，构建调用关系图
        traverseDirectory(srcDir);

        // 输出调用关系：从根节点开始层级打印调用链
        printCallChains();
    }

    // 递归遍历目录下所有 Java 文件
    private static void traverseDirectory(File directory) throws Exception {
        for (File file : Objects.requireNonNull(directory.listFiles())) {
            if (file.isDirectory()) {
                traverseDirectory(file);
            } else if (file.getName().endsWith(".java")) {
                processFile(file);
            }
        }
    }

    // 解析单个文件，提取方法调用关系
    private static void processFile(File file) {
        try (FileInputStream fis = new FileInputStream(file)) {
            CompilationUnit cu = StaticJavaParser.parse(fis);
            // 遍历当前文件中的所有方法声明
            cu.findAll(MethodDeclaration.class).forEach(methodDeclaration -> {
                try {
                    // resolve() 获取调用者方法的全限定签名
                    String callerSignature = methodDeclaration.resolve().getQualifiedSignature();

                    // 遍历该方法体内的所有方法调用表达式
                    methodDeclaration.findAll(MethodCallExpr.class).forEach(methodCall -> {
                        try {
                            ResolvedMethodDeclaration resolvedCallee = methodCall.resolve();
                            // 过滤掉外部调用：判断被调用方法的声明类是否属于工程内代码
                            ResolvedReferenceTypeDeclaration declaringType = resolvedCallee.declaringType();
                            String declaringTypeName = declaringType.getQualifiedName();
                            if (!declaringTypeName.startsWith(projectPackagePrefix)) {
                                // 如果不是以项目包名前缀开始，则认为是外部调用，忽略掉
                                return;
                            }
                            String calleeSignature = resolvedCallee.getQualifiedSignature();
                            // 建立调用关系：caller -> callee
                            callGraph.computeIfAbsent(callerSignature, k -> new HashSet<>()).add(calleeSignature);
                        } catch (Exception e) {
                            // 对于无法解析的调用打印提示（例如动态调用、反射等情况）
                            System.err.println("无法解析调用: " + methodCall + " - " + e.getMessage());
                        }
                    });
                } catch (Exception e) {
                    System.err.println("无法解析方法声明: " + methodDeclaration.getNameAsString() + " - " + e.getMessage());
                }
            });
        } catch (Exception e) {
            System.err.println("处理文件失败: " + file.getAbsolutePath() + " - " + e.getMessage());
        }
    }

    // 打印调用链：先找出根节点（没有作为被调用者出现的方法），然后递归打印整个调用链
    private static void printCallChains() {
        // 收集所有调用者和被调用者
        Set<String> allCallers = new HashSet<>(callGraph.keySet());
        Set<String> allCallees = new HashSet<>();
        for (Set<String> callees : callGraph.values()) {
            allCallees.addAll(callees);
        }
        // 根节点：只出现在调用者中，但不作为被调用者出现
        Set<String> roots = new HashSet<>(allCallers);
        roots.removeAll(allCallees);

        // 如果没有根节点，则所有节点可能都有循环调用，直接全部输出
        if (roots.isEmpty()) {
            roots = allCallers;
        }

        for (String root : roots) {
            printChain(root, new HashSet<>(), 0);
        }
    }

    // 递归打印调用链，visited 用于防止无限循环
    private static void printChain(String method, Set<String> visited, int depth) {
        // 缩进显示层级
        for (int i = 0; i < depth; i++) {
            System.out.print("    ");
        }
        System.out.println(method);

        // 如果已经访问过该节点，则避免循环（这里每条链单独复制 visited 集合）
        if (visited.contains(method)) {
            return;
        }
        visited.add(method);

        // 递归遍历该方法调用的所有被调用方法
        Set<String> callees = callGraph.get(method);
        if (callees != null) {
            for (String callee : callees) {
                printChain(callee, new HashSet<>(visited), depth + 1);
            }
        }
    }
}






import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.symbolsolver.JavaSymbolSolver;
import com.github.javaparser.symbolsolver.model.resolution.SymbolReference;
import com.github.javaparser.symbolsolver.model.resolution.TypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;
import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;

import java.io.File;
import java.io.FileInputStream;
import java.util.*;

public class CallGraphAnalyzer {

    // 保存调用关系：caller方法 -> set(被调用方法)
    private static final Map<String, Set<String>> callGraph = new HashMap<>();

    public static void main(String[] args) throws Exception {
        // 配置类型求解器（这里假设你的源码目录为 "your/project/src"）
        File srcDir = new File("your/project/src"); // 请替换为实际的源码目录
        TypeSolver reflectionTypeSolver = new ReflectionTypeSolver();
        TypeSolver javaParserTypeSolver = new JavaParserTypeSolver(srcDir);
        CombinedTypeSolver combinedTypeSolver = new CombinedTypeSolver(reflectionTypeSolver, javaParserTypeSolver);
        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(combinedTypeSolver);
        StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);

        // 遍历整个工程（源码目录下的所有 .java 文件）
        traverseDirectory(srcDir);

        // 输出调用关系
        for (Map.Entry<String, Set<String>> entry : callGraph.entrySet()) {
            String caller = entry.getKey();
            for (String callee : entry.getValue()) {
                System.out.println(caller + " -> " + callee);
            }
        }
    }

    // 递归遍历目录下所有 Java 文件
    private static void traverseDirectory(File directory) throws Exception {
        for (File file : Objects.requireNonNull(directory.listFiles())) {
            if (file.isDirectory()) {
                traverseDirectory(file);
            } else if (file.getName().endsWith(".java")) {
                processFile(file);
            }
        }
    }

    // 解析单个文件，提取方法调用关系
    private static void processFile(File file) {
        try (FileInputStream fis = new FileInputStream(file)) {
            CompilationUnit cu = StaticJavaParser.parse(fis);

            // 遍历文件中的所有方法声明
            cu.findAll(MethodDeclaration.class).forEach(methodDeclaration -> {
                try {
                    // 利用符号求解器解析方法声明，获取调用者的全限定签名
                    String callerSignature = methodDeclaration.resolve().getQualifiedSignature();

                    // 在该方法体内查找所有方法调用表达式
                    methodDeclaration.findAll(MethodCallExpr.class).forEach(methodCall -> {
                        try {
                            ResolvedMethodDeclaration resolvedCallee = methodCall.resolve();
                            String calleeSignature = resolvedCallee.getQualifiedSignature();
                            // 建立调用关系：caller -> callee
                            callGraph.computeIfAbsent(callerSignature, k -> new HashSet<>()).add(calleeSignature);
                        } catch (Exception e) {
                            // 无法解析的调用打印提示（可能涉及动态调用、反射等情况）
                            System.err.println("无法解析调用: " + methodCall + " - " + e.getMessage());
                        }
                    });
                } catch (Exception e) {
                    System.err.println("无法解析方法声明: " + methodDeclaration.getNameAsString() + " - " + e.getMessage());
                }
            });
        } catch (Exception e) {
            System.err.println("处理文件失败: " + file.getAbsolutePath() + " - " + e.getMessage());
        }
    }
}





import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.symbolsolver.JavaSymbolSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;
import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;

import java.io.File;
import java.io.FileInputStream;
import java.util.*;

public class CallGraphAnalyzer {

    // 保存调用关系：caller方法 -> set(被调用方法)
    private static final Map<String, Set<String>> callGraph = new HashMap<>();

    public static void main(String[] args) throws Exception {
        // 配置类型求解器（假设你的源码目录为 "your/project/src"）
        File srcDir = new File("your/project/src"); // 请替换为实际的源码路径
        CombinedTypeSolver combinedTypeSolver = new CombinedTypeSolver();
        combinedTypeSolver.add(new ReflectionTypeSolver());
        combinedTypeSolver.add(new JavaParserTypeSolver(srcDir));

        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(combinedTypeSolver);
        StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);

        // 遍历整个工程的 .java 文件
        traverseDirectory(srcDir);

        // 输出调用关系
        for (Map.Entry<String, Set<String>> entry : callGraph.entrySet()) {
            String caller = entry.getKey();
            for (String callee : entry.getValue()) {
                System.out.println(caller + " -> " + callee);
            }
        }
    }

    // 递归遍历目录下所有 Java 文件
    private static void traverseDirectory(File directory) throws Exception {
        for (File file : Objects.requireNonNull(directory.listFiles())) {
            if (file.isDirectory()) {
                traverseDirectory(file);
            } else if (file.getName().endsWith(".java")) {
                processFile(file);
            }
        }
    }

    // 解析单个文件，提取方法调用关系
    private static void processFile(File file) {
        try (FileInputStream fis = new FileInputStream(file)) {
            CompilationUnit cu = StaticJavaParser.parse(fis);

            // 遍历当前文件中所有方法声明
            cu.findAll(MethodDeclaration.class).forEach(methodDeclaration -> {
                try {
                    // resolve() 获取调用者方法的全限定签名
                    String callerSignature = methodDeclaration.resolve().getQualifiedSignature();

                    // 在该方法体内查找所有方法调用
                    methodDeclaration.findAll(MethodCallExpr.class).forEach(methodCall -> {
                        try {
                            ResolvedMethodDeclaration resolvedCallee = methodCall.resolve();
                            String calleeSignature = resolvedCallee.getQualifiedSignature();
                            // 建立调用关系：caller -> callee
                            callGraph.computeIfAbsent(callerSignature, k -> new HashSet<>()).add(calleeSignature);
                        } catch (Exception e) {
                            // 无法解析的调用（可能涉及反射或动态调用）时打印提示
                            System.err.println("无法解析调用: " + methodCall + " - " + e.getMessage());
                        }
                    });
                } catch (Exception e) {
                    System.err.println("无法解析方法声明: " + methodDeclaration.getNameAsString() + " - " + e.getMessage());
                }
            });
        } catch (Exception e) {
            System.err.println("处理文件失败: " + file.getAbsolutePath() + " - " + e.getMessage());
        }
    }
}
