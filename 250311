import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.FieldDeclaration;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.body.VariableDeclarator;
import com.github.javaparser.ast.expr.*;
import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;
import com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;
import com.github.javaparser.symbolsolver.JavaSymbolSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;

import java.io.*;
import java.util.*;

public class MethodCallAnalyzer {
    private static final Map<String, Set<String>> callGraph = new HashMap<>();
    private static final String OUTPUT_FILE = "call_graph.txt";
    private static CombinedTypeSolver typeSolver;
    private static final String PROJECT_PACKAGE_PREFIX = "com.myproject"; // å·¥ç¨‹åŒ…åå‰ç¼€

    public static void main(String[] args) throws IOException {
        File srcRoot = new File("your/project/src/main/java"); // è®¾ç½®æºç æ ¹ç›®å½•

        // åˆå§‹åŒ–è§£æå™¨
        typeSolver = new CombinedTypeSolver();
        typeSolver.add(new ReflectionTypeSolver()); // è§£æ JDK æ–¹æ³•
        typeSolver.add(new JavaParserTypeSolver(srcRoot)); // è§£æå·¥ç¨‹æºç 
        StaticJavaParser.getConfiguration().setSymbolResolver(new JavaSymbolSolver(typeSolver));

        // éå†æºç ç›®å½•
        analyzeProject(srcRoot);

        // å†™å…¥è°ƒç”¨å…³ç³»
        writeResults();
    }

    private static void analyzeProject(File directory) {
        for (File file : Objects.requireNonNull(directory.listFiles())) {
            if (file.isDirectory()) {
                analyzeProject(file);
            } else if (file.getName().endsWith(".java")) {
                analyzeFile(file);
            }
        }
    }

    private static void analyzeFile(File file) {
        try (FileInputStream fis = new FileInputStream(file)) {
            CompilationUnit cu = StaticJavaParser.parse(fis);

            // è§£æå­—æ®µå®šä¹‰ï¼ˆåŒ…æ‹¬ @Autowiredï¼‰
            Map<String, String> fieldTypeMap = new HashMap<>();
            cu.findAll(FieldDeclaration.class).forEach(field -> processFieldDeclaration(field, fieldTypeMap));

            // è§£ææ–¹æ³•è°ƒç”¨
            cu.findAll(MethodDeclaration.class).forEach(methodDeclaration -> {
                try {
                    String callerSignature = methodDeclaration.resolve().getQualifiedSignature();
                    methodDeclaration.findAll(MethodCallExpr.class).forEach(methodCall -> processMethodCall(callerSignature, methodCall, fieldTypeMap));
                } catch (Exception e) {
                    System.err.println("æ— æ³•è§£ææ–¹æ³•ï¼š" + methodDeclaration.getNameAsString());
                }
            });
        } catch (Exception e) {
            System.err.println("æ— æ³•è§£ææ–‡ä»¶ï¼š" + file.getAbsolutePath());
        }
    }

    /**
     * è§£æå­—æ®µå£°æ˜ï¼Œæ”¯æŒ @Autowired/@Resource æ³¨å…¥
     */
    private static void processFieldDeclaration(FieldDeclaration field, Map<String, String> fieldTypeMap) {
        for (VariableDeclarator var : field.getVariables()) {
            String varName = var.getNameAsString();
            try {
                String varType = var.getType().resolve().describe();
                fieldTypeMap.put(varName, varType);
            } catch (Exception e) {
                System.err.println("æ— æ³•è§£æå­—æ®µï¼š" + varName);
            }
        }
    }

    /**
     * è§£ææ–¹æ³•è°ƒç”¨ï¼Œå¹¶å­˜å‚¨è°ƒç”¨å…³ç³»
     */
    private static void processMethodCall(String callerSignature, MethodCallExpr methodCall, Map<String, String> fieldTypeMap) {
        try {
            ResolvedMethodDeclaration resolvedMethod = methodCall.resolve();
            ResolvedReferenceTypeDeclaration declaringType = resolvedMethod.declaringType();

            // è¿‡æ»¤ JDK å’Œç¬¬ä¸‰æ–¹åº“
            if (!declaringType.getQualifiedName().startsWith(PROJECT_PACKAGE_PREFIX)) {
                return;
            }

            String calleeSignature = resolvedMethod.getQualifiedSignature();

            // å¤„ç†å®ä¾‹è°ƒç”¨
            if (methodCall.getScope().isPresent()) {
                Expression scope = methodCall.getScope().get();
                if (scope.isNameExpr()) {
                    String varName = scope.asNameExpr().getNameAsString();
                    if (fieldTypeMap.containsKey(varName)) {
                        String inferredClass = fieldTypeMap.get(varName);
                        calleeSignature = inferredClass + "." + resolvedMethod.getSignature();
                    }
                }
            }

            // å­˜å‚¨è°ƒç”¨å…³ç³»
            callGraph.computeIfAbsent(callerSignature, k -> new HashSet<>()).add(calleeSignature);
        } catch (Exception e) {
            System.err.println("è§£æå¤±è´¥ï¼š" + methodCall);
        }
    }

    /**
     * å°†è°ƒç”¨å…³ç³»å†™å…¥æ–‡ä»¶
     */
    private static void writeResults() {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(OUTPUT_FILE))) {
            for (Map.Entry<String, Set<String>> entry : callGraph.entrySet()) {
                writer.write(entry.getKey() + "\n");
                for (String callee : entry.getValue()) {
                    writer.write("    â†’ " + callee + "\n");
                }
            }
            System.out.println("è°ƒç”¨å…³ç³»å·²å†™å…¥ï¼š" + OUTPUT_FILE);
        } catch (IOException e) {
            System.err.println("å†™å…¥æ–‡ä»¶å¤±è´¥ï¼š" + e.getMessage());
        }
    }
}

import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.symbolsolver.JavaSymbolSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;
import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;
import com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;

import java.io.*;
import java.util.*;

public class CallGraphAnalyzer {

    // å­˜å‚¨è°ƒç”¨å…³ç³»ï¼šcaller æ–¹æ³• -> è¢«è°ƒç”¨æ–¹æ³•é›†åˆ
    private static final Map<String, Set<String>> callGraph = new HashMap<>();
    // è¯·æ›¿æ¢ä¸ºä½ å·¥ç¨‹å†…éƒ¨çš„åŒ…åå‰ç¼€ï¼Œæ¯”å¦‚ "com.myproject"
    private static final String projectPackagePrefix = "com.myproject";
    private static final String OUTPUT_FILE = "call_graph.txt";
    private static CombinedTypeSolver combinedTypeSolver;

    public static void main(String[] args) throws Exception {
        File srcDir = new File("your/project/src"); // è¯·ç¡®ä¿è¿™æ˜¯ä½ çš„æºç æ ¹ç›®å½•ï¼ˆåŒ…çš„èµ·ç‚¹ï¼‰
        System.out.println("è§£ææºç è·¯å¾„: " + srcDir.getAbsolutePath());

        // åˆå§‹åŒ– TypeSolverï¼Œç¡®ä¿èƒ½è§£ææ•´ä¸ªé¡¹ç›®
        combinedTypeSolver = new CombinedTypeSolver();
        combinedTypeSolver.add(new ReflectionTypeSolver(false)); // è§£æ JDK å†…éƒ¨çš„ç±»
        combinedTypeSolver.add(new JavaParserTypeSolver(srcDir));  // è§£æé¡¹ç›®æºç 

        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(combinedTypeSolver);
        StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);

        System.out.println("å¼€å§‹è§£æå·¥ç¨‹...");
        traverseDirectory(srcDir);
        System.out.println("è§£æå®Œæˆï¼Œæ­£åœ¨å†™å…¥è°ƒç”¨å…³ç³»...");

        writeCallChainsToFile();
        System.out.println("è°ƒç”¨å…³ç³»å·²å†™å…¥æ–‡ä»¶: " + OUTPUT_FILE);
    }

    // éå†ç›®å½•ä¸‹æ‰€æœ‰ .java æ–‡ä»¶
    private static void traverseDirectory(File directory) throws Exception {
        for (File file : Objects.requireNonNull(directory.listFiles())) {
            if (file.isDirectory()) {
                traverseDirectory(file);
            } else if (file.getName().endsWith(".java")) {
                processFile(file);
            }
        }
    }

    // è§£æå•ä¸ª Java æ–‡ä»¶ï¼Œæå–æ–¹æ³•è°ƒç”¨å…³ç³»
    private static void processFile(File file) {
        System.out.println("è§£ææ–‡ä»¶: " + file.getName());
        try (FileInputStream fis = new FileInputStream(file)) {
            CompilationUnit cu = StaticJavaParser.parse(fis);
            cu.findAll(MethodDeclaration.class).forEach(methodDeclaration -> {
                try {
                    String callerSignature = methodDeclaration.resolve().getQualifiedSignature();
                    methodDeclaration.findAll(MethodCallExpr.class).forEach(methodCall -> {
                        // ä½¿ç”¨ tryResolve åŒ…è£…è§£æè¿‡ç¨‹
                        Optional<ResolvedMethodDeclaration> opt = tryResolve(methodCall);
                        if (opt.isPresent()) {
                            ResolvedMethodDeclaration resolvedCallee = opt.get();
                            // è·å–è¢«è°ƒç”¨æ–¹æ³•æ‰€åœ¨çš„ç±»
                            ResolvedReferenceTypeDeclaration declaringType = resolvedCallee.declaringType();
                            String declaringTypeName = declaringType.getQualifiedName();
                            // è¿‡æ»¤æ‰éé¡¹ç›®å†…éƒ¨çš„è°ƒç”¨ï¼ˆä¾‹å¦‚ JDK æˆ–ç¬¬ä¸‰æ–¹åº“ï¼‰
                            if (!declaringTypeName.startsWith(projectPackagePrefix)) {
                                return;
                            }
                            String calleeSignature = resolvedCallee.getQualifiedSignature();
                            callGraph.computeIfAbsent(callerSignature, k -> new HashSet<>()).add(calleeSignature);
                            System.out.println("è§£ææˆåŠŸ: " + callerSignature + " è°ƒç”¨äº† " + calleeSignature);
                        }
                    });
                } catch (Exception e) {
                    System.err.println("è§£ææ–¹æ³•å£°æ˜å¤±è´¥: " + methodDeclaration.getNameAsString() + " - " + e.getMessage());
                }
            });
        } catch (Exception e) {
            System.err.println("å¤„ç†æ–‡ä»¶å¤±è´¥: " + file.getAbsolutePath() + " - " + e.getMessage());
        }
    }

    /**
     * å°è¯•è§£æ MethodCallExprï¼Œå¦‚æœè§£ææˆåŠŸåˆ™è¿”å› Optional åŒ…è£…çš„ ResolvedMethodDeclarationï¼Œ
     * å¦åˆ™è¿”å› Optional.empty()ã€‚
     */
    private static Optional<ResolvedMethodDeclaration> tryResolve(MethodCallExpr methodCall) {
        try {
            return Optional.of(methodCall.resolve());
        } catch (Exception e) {
            System.err.println("è§£ææ–¹æ³•è°ƒç”¨å¤±è´¥: " + methodCall + " - " + e.getMessage());
            return Optional.empty();
        }
    }

    // å°†è°ƒç”¨å…³ç³»å†™å…¥æ–‡ä»¶
    private static void writeCallChainsToFile() {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(OUTPUT_FILE))) {
            // ç®€å•å†™å‡ºæ¯ä¸ªè°ƒç”¨è€…ä¸å¯¹åº”çš„è¢«è°ƒç”¨è€…
            for (String caller : callGraph.keySet()) {
                writer.write(caller + "\n");
                for (String callee : callGraph.get(caller)) {
                    writer.write("    â†’ " + callee + "\n");
                }
            }
        } catch (IOException e) {
            System.err.println("å†™å…¥æ–‡ä»¶å¤±è´¥: " + e.getMessage());
        }
    }
}




import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.symbolsolver.JavaSymbolSolver;
import com.github.javaparser.symbolsolver.model.resolution.SymbolReference;
import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;
import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;
import com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;

import java.io.*;
import java.util.*;

public class CallGraphAnalyzer {
    private static final Map<String, Set<String>> callGraph = new HashMap<>();
    private static final String projectPackagePrefix = "com.myproject"; // ä½ çš„å·¥ç¨‹åŒ…å
    private static final String OUTPUT_FILE = "call_graph.txt"; // è¾“å‡ºæ–‡ä»¶è·¯å¾„
    private static CombinedTypeSolver combinedTypeSolver;

    public static void main(String[] args) throws Exception {
        File srcDir = new File("your/project/src"); // **ç¡®ä¿è¿™æ˜¯ä½ çš„ src ç›®å½•**
        System.out.println("âœ… JavaParserTypeSolver è§£æè·¯å¾„: " + srcDir.getAbsolutePath());

        combinedTypeSolver = new CombinedTypeSolver();
        combinedTypeSolver.add(new ReflectionTypeSolver(false)); // è§£æ JDK ç±»
        combinedTypeSolver.add(new JavaParserTypeSolver(srcDir)); // è§£æ Java æºç 

        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(combinedTypeSolver);
        StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);

        System.out.println("ğŸ” å¼€å§‹è§£æå·¥ç¨‹...");
        traverseDirectory(srcDir);
        System.out.println("âœ… è§£æå®Œæˆï¼æ­£åœ¨å†™å…¥è°ƒç”¨å…³ç³»...");

        writeCallChainsToFile();
        System.out.println("ğŸ“„ è°ƒç”¨å…³ç³»å·²å†™å…¥: " + OUTPUT_FILE);
    }

    private static void traverseDirectory(File directory) throws Exception {
        for (File file : Objects.requireNonNull(directory.listFiles())) {
            if (file.isDirectory()) {
                traverseDirectory(file);
            } else if (file.getName().endsWith(".java")) {
                processFile(file);
            }
        }
    }

    private static void processFile(File file) {
        System.out.println("ğŸ“‚ æ­£åœ¨è§£ææ–‡ä»¶: " + file.getName());
        try (FileInputStream fis = new FileInputStream(file)) {
            CompilationUnit cu = StaticJavaParser.parse(fis);
            cu.findAll(MethodDeclaration.class).forEach(methodDeclaration -> {
                try {
                    String callerSignature = methodDeclaration.resolve().getQualifiedSignature();

                    methodDeclaration.findAll(MethodCallExpr.class).forEach(methodCall -> {
                        try {
                            System.out.println("ğŸ” AST æ–¹æ³•è°ƒç”¨: " + methodCall);
                            System.out.println("ğŸ” æ–¹æ³•æ‰€å±ç±»: " + methodCall.getScope().orElse(null));

                            SymbolReference<ResolvedMethodDeclaration> ref = combinedTypeSolver.tryToSolveMethod(
                                    "com.myproject.B", "methodX"
                            );
                            if (!ref.isSolved()) {
                                System.err.println("âš ï¸ `methodX()` è§£æå¤±è´¥ï¼Œè·³è¿‡");
                                return;
                            }

                            ResolvedMethodDeclaration resolvedCallee = methodCall.resolve();
                            ResolvedReferenceTypeDeclaration declaringType = resolvedCallee.declaringType();
                            String declaringTypeName = declaringType.getQualifiedName();

                            if (!declaringTypeName.startsWith(projectPackagePrefix)) {
                                return;
                            }

                            String calleeSignature = resolvedCallee.getQualifiedSignature();
                            callGraph.computeIfAbsent(callerSignature, k -> new HashSet<>()).add(calleeSignature);

                            System.out.println("ğŸ”— " + callerSignature + " è°ƒç”¨äº† " + calleeSignature);
                        } catch (Exception e) {
                            System.err.println("âš ï¸ æ–¹æ³•è§£æå¤±è´¥: " + methodCall + " - " + e.getMessage());
                        }
                    });
                } catch (Exception e) {
                    System.err.println("âŒ æ–¹æ³•å£°æ˜è§£æå¤±è´¥: " + methodDeclaration.getNameAsString() + " - " + e.getMessage());
                }
            });
        } catch (Exception e) {
            System.err.println("âŒ å¤„ç†å¤±è´¥: " + file.getAbsolutePath() + " - " + e.getMessage());
        }
    }

    private static void writeCallChainsToFile() {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(OUTPUT_FILE))) {
            for (String caller : callGraph.keySet()) {
                writer.write(caller + "\n");
                for (String callee : callGraph.get(caller)) {
                    writer.write("    â†’ " + callee + "\n");
                }
            }
            System.out.println("âœ… è°ƒç”¨å…³ç³»å·²æˆåŠŸå†™å…¥: " + OUTPUT_FILE);
        } catch (IOException e) {
            System.err.println("âŒ å†™å…¥æ–‡ä»¶å¤±è´¥: " + e.getMessage());
        }
    }
}


import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.symbolsolver.JavaSymbolSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;
import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;
import com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;

import java.io.*;
import java.util.*;

public class CallGraphAnalyzer {

    private static final Map<String, Set<String>> callGraph = new HashMap<>();
    private static final String projectPackagePrefix = "com.myproject"; // ä½ çš„å·¥ç¨‹åŒ…å
    private static final String OUTPUT_FILE = "call_graph.txt"; // è¾“å‡ºæ–‡ä»¶è·¯å¾„
    private static CombinedTypeSolver combinedTypeSolver;

    public static void main(String[] args) throws Exception {
        File srcDir = new File("your/project/src"); // **ç¡®ä¿è¿™æ˜¯ä½ çš„ src ç›®å½•**

        // **ç¡®ä¿ TypeSolver è§£ææ•´ä¸ªé¡¹ç›®**
        combinedTypeSolver = new CombinedTypeSolver();
        combinedTypeSolver.add(new ReflectionTypeSolver()); // è§£æ JDK ç±»
        combinedTypeSolver.add(new JavaParserTypeSolver(srcDir)); // è§£æ Java æºç 

        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(combinedTypeSolver);
        StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);

        System.out.println("è§£æå¼€å§‹...");
        traverseDirectory(srcDir);
        System.out.println("è§£æå®Œæˆï¼æ­£åœ¨å†™å…¥æ–‡ä»¶...");

        writeCallChainsToFile();
        System.out.println("è°ƒç”¨å…³ç³»å·²å†™å…¥: " + OUTPUT_FILE);
    }

    // éå†æ•´ä¸ª Java ç›®å½•
    private static void traverseDirectory(File directory) throws Exception {
        for (File file : Objects.requireNonNull(directory.listFiles())) {
            if (file.isDirectory()) {
                traverseDirectory(file);
            } else if (file.getName().endsWith(".java")) {
                processFile(file);
            }
        }
    }

    // è§£æ Java æ–‡ä»¶ï¼Œæå–æ–¹æ³•è°ƒç”¨å…³ç³»
    private static void processFile(File file) {
        System.out.println("æ­£åœ¨è§£ææ–‡ä»¶: " + file.getName());
        try (FileInputStream fis = new FileInputStream(file)) {
            CompilationUnit cu = StaticJavaParser.parse(fis);
            cu.findAll(MethodDeclaration.class).forEach(methodDeclaration -> {
                try {
                    String callerSignature = methodDeclaration.resolve().getQualifiedSignature();

                    methodDeclaration.findAll(MethodCallExpr.class).forEach(methodCall -> {
                        try {
                            ResolvedMethodDeclaration resolvedCallee = methodCall.resolve();
                            ResolvedReferenceTypeDeclaration declaringType = resolvedCallee.declaringType();
                            String declaringTypeName = declaringType.getQualifiedName();

                            // **åªè§£æå·¥ç¨‹å†…éƒ¨çš„æ–¹æ³•è°ƒç”¨**
                            if (!declaringTypeName.startsWith(projectPackagePrefix)) {
                                return;
                            }

                            String calleeSignature = resolvedCallee.getQualifiedSignature();
                            callGraph.computeIfAbsent(callerSignature, k -> new HashSet<>()).add(calleeSignature);

                            System.out.println("âœ… " + callerSignature + " è°ƒç”¨äº† " + calleeSignature);
                        } catch (Exception e) {
                            System.err.println("âŒ æ–¹æ³•è§£æå¤±è´¥: " + methodCall + " - " + e.getMessage());
                        }
                    });
                } catch (Exception e) {
                    System.err.println("âŒ æ–¹æ³•å£°æ˜è§£æå¤±è´¥: " + methodDeclaration.getNameAsString() + " - " + e.getMessage());
                }
            });
        } catch (Exception e) {
            System.err.println("âŒ å¤„ç†å¤±è´¥: " + file.getAbsolutePath() + " - " + e.getMessage());
        }
    }

    // å†™å…¥è°ƒç”¨é“¾åˆ°æ–‡ä»¶
    private static void writeCallChainsToFile() {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(OUTPUT_FILE))) {
            for (String caller : callGraph.keySet()) {
                writer.write(caller + "\n");
                for (String callee : callGraph.get(caller)) {
                    writer.write("    â†’ " + callee + "\n");
                }
            }
            System.out.println("âœ… è°ƒç”¨å…³ç³»å·²æˆåŠŸå†™å…¥: " + OUTPUT_FILE);
        } catch (IOException e) {
            System.err.println("âŒ å†™å…¥æ–‡ä»¶å¤±è´¥: " + e.getMessage());
        }
    }
}




import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.symbolsolver.JavaSymbolSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;
import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;
import com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;

import java.io.*;
import java.util.*;

public class CallGraphAnalyzer {

    private static final Map<String, Set<String>> callGraph = new HashMap<>();
    private static final String projectPackagePrefix = "com.myproject"; // æ›¿æ¢æˆä½ çš„åŒ…å
    private static final String OUTPUT_FILE = "call_graph.txt"; // è¾“å‡ºæ–‡ä»¶è·¯å¾„
    private static CombinedTypeSolver combinedTypeSolver;

    public static void main(String[] args) throws Exception {
        File srcDir = new File("your/project/src"); // ä½ çš„ Java æºç ç›®å½•

        // åˆå§‹åŒ– TypeSolverï¼Œç¡®ä¿å¯ä»¥è§£ææ•´ä¸ªé¡¹ç›®ä»£ç 
        combinedTypeSolver = new CombinedTypeSolver();
        combinedTypeSolver.add(new ReflectionTypeSolver()); // è§£æ JDK ç±»
        combinedTypeSolver.add(new JavaParserTypeSolver(srcDir)); // è§£æ Java æºç 

        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(combinedTypeSolver);
        StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);

        // è§£ææ•´ä¸ªå·¥ç¨‹çš„è°ƒç”¨å…³ç³»
        traverseDirectory(srcDir);

        // å°†è°ƒç”¨å…³ç³»å†™å…¥æ–‡ä»¶
        writeCallChainsToFile();
    }

    // éå†æ‰€æœ‰ Java æ–‡ä»¶
    private static void traverseDirectory(File directory) throws Exception {
        for (File file : Objects.requireNonNull(directory.listFiles())) {
            if (file.isDirectory()) {
                traverseDirectory(file);
            } else if (file.getName().endsWith(".java")) {
                processFile(file);
            }
        }
    }

    // è§£æ Java æ–‡ä»¶ï¼Œæå–æ–¹æ³•è°ƒç”¨å…³ç³»
    private static void processFile(File file) {
        try (FileInputStream fis = new FileInputStream(file)) {
            CompilationUnit cu = StaticJavaParser.parse(fis);
            cu.findAll(MethodDeclaration.class).forEach(methodDeclaration -> {
                try {
                    String callerSignature = methodDeclaration.resolve().getQualifiedSignature();

                    // è§£ææ–¹æ³•ä½“å†…æ‰€æœ‰æ–¹æ³•è°ƒç”¨
                    methodDeclaration.findAll(MethodCallExpr.class).forEach(methodCall -> {
                        try {
                            ResolvedMethodDeclaration resolvedCallee = methodCall.resolve();
                            ResolvedReferenceTypeDeclaration declaringType = resolvedCallee.declaringType();
                            String declaringTypeName = declaringType.getQualifiedName();

                            // è¿‡æ»¤éå·¥ç¨‹å†…éƒ¨çš„æ–¹æ³•
                            if (!declaringTypeName.startsWith(projectPackagePrefix)) {
                                return;
                            }

                            String calleeSignature = resolvedCallee.getQualifiedSignature();
                            callGraph.computeIfAbsent(callerSignature, k -> new HashSet<>()).add(calleeSignature);
                        } catch (Exception e) {
                            System.err.println("è§£æå¤±è´¥: " + methodCall + " - " + e.getMessage());
                        }
                    });
                } catch (Exception e) {
                    System.err.println("è§£æå¤±è´¥: " + methodDeclaration.getNameAsString() + " - " + e.getMessage());
                }
            });
        } catch (Exception e) {
            System.err.println("å¤„ç†å¤±è´¥: " + file.getAbsolutePath() + " - " + e.getMessage());
        }
    }

    // å†™å…¥è°ƒç”¨é“¾åˆ°æ–‡ä»¶
    private static void writeCallChainsToFile() {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(OUTPUT_FILE))) {
            Set<String> allCallers = new HashSet<>(callGraph.keySet());
            Set<String> allCallees = new HashSet<>();
            for (Set<String> callees : callGraph.values()) {
                allCallees.addAll(callees);
            }

            // æ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼ˆåªä½œä¸ºè°ƒç”¨è€…ï¼Œä¸æ˜¯è¢«è°ƒç”¨è€…ï¼‰
            Set<String> roots = new HashSet<>(allCallers);
            roots.removeAll(allCallees);

            if (roots.isEmpty()) {
                roots = allCallers; // å¯èƒ½æ‰€æœ‰æ–¹æ³•éƒ½æœ‰ç›¸äº’è°ƒç”¨
            }

            for (String root : roots) {
                writeChain(writer, root, new HashSet<>(), 0);
            }

            System.out.println("è°ƒç”¨å…³ç³»å·²å†™å…¥: " + OUTPUT_FILE);
        } catch (IOException e) {
            System.err.println("å†™å…¥æ–‡ä»¶å¤±è´¥: " + e.getMessage());
        }
    }

    // é€’å½’å†™å…¥è°ƒç”¨é“¾
    private static void writeChain(BufferedWriter writer, String method, Set<String> visited, int depth) throws IOException {
        for (int i = 0; i < depth; i++) {
            writer.write("    ");
        }
        writer.write(method + "\n");

        if (visited.contains(method)) {
            return;
        }
        visited.add(method);

        Set<String> callees = callGraph.get(method);
        if (callees != null) {
            for (String callee : callees) {
                writeChain(writer, callee, new HashSet<>(visited), depth + 1);
            }
        }
    }
}





import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.symbolsolver.JavaSymbolSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;
import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;
import com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;

import java.io.*;
import java.util.*;

public class CallGraphAnalyzer {

    // å­˜å‚¨è°ƒç”¨å…³ç³»ï¼šcaller æ–¹æ³• -> è¢«è°ƒç”¨æ–¹æ³•é›†åˆ
    private static final Map<String, Set<String>> callGraph = new HashMap<>();
    private static final String projectPackagePrefix = "com.myproject"; // è¯·ä¿®æ”¹ä¸ºä½ å·¥ç¨‹çš„åŒ…å
    private static final String OUTPUT_FILE = "call_graph.txt"; // è¾“å‡ºæ–‡ä»¶è·¯å¾„

    public static void main(String[] args) throws Exception {
        File srcDir = new File("your/project/src"); // æ›¿æ¢æˆä½ çš„æºç è·¯å¾„

        CombinedTypeSolver combinedTypeSolver = new CombinedTypeSolver();
        combinedTypeSolver.add(new ReflectionTypeSolver()); // è§£æ JDK
        combinedTypeSolver.add(new JavaParserTypeSolver(srcDir)); // è§£æ Java æºç 

        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(combinedTypeSolver);
        StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);

        // éå†æ•´ä¸ªå·¥ç¨‹çš„ .java æ–‡ä»¶ï¼Œè§£ææ–¹æ³•è°ƒç”¨å…³ç³»
        traverseDirectory(srcDir);

        // å°†è°ƒç”¨é“¾å†™å…¥æ–‡ä»¶
        writeCallChainsToFile();
    }

    // éå†æ‰€æœ‰ Java æ–‡ä»¶
    private static void traverseDirectory(File directory) throws Exception {
        for (File file : Objects.requireNonNull(directory.listFiles())) {
            if (file.isDirectory()) {
                traverseDirectory(file);
            } else if (file.getName().endsWith(".java")) {
                processFile(file);
            }
        }
    }

    // è§£æå•ä¸ª Java æ–‡ä»¶ï¼Œæå–æ–¹æ³•è°ƒç”¨å…³ç³»
    private static void processFile(File file) {
        try (FileInputStream fis = new FileInputStream(file)) {
            CompilationUnit cu = StaticJavaParser.parse(fis);
            cu.findAll(MethodDeclaration.class).forEach(methodDeclaration -> {
                try {
                    String callerSignature = methodDeclaration.resolve().getQualifiedSignature();
                    methodDeclaration.findAll(MethodCallExpr.class).forEach(methodCall -> {
                        try {
                            ResolvedMethodDeclaration resolvedCallee = methodCall.resolve();
                            ResolvedReferenceTypeDeclaration declaringType = resolvedCallee.declaringType();
                            String declaringTypeName = declaringType.getQualifiedName();

                            // åªè§£æå·¥ç¨‹å†…éƒ¨çš„æ–¹æ³•è°ƒç”¨
                            if (!declaringTypeName.startsWith(projectPackagePrefix)) {
                                return;
                            }

                            String calleeSignature = resolvedCallee.getQualifiedSignature();
                            callGraph.computeIfAbsent(callerSignature, k -> new HashSet<>()).add(calleeSignature);
                        } catch (Exception e) {
                            System.err.println("æ— æ³•è§£æè°ƒç”¨: " + methodCall + " - " + e.getMessage());
                        }
                    });
                } catch (Exception e) {
                    System.err.println("æ— æ³•è§£ææ–¹æ³•å£°æ˜: " + methodDeclaration.getNameAsString() + " - " + e.getMessage());
                }
            });
        } catch (Exception e) {
            System.err.println("å¤„ç†æ–‡ä»¶å¤±è´¥: " + file.getAbsolutePath() + " - " + e.getMessage());
        }
    }

    // å†™å…¥è°ƒç”¨é“¾åˆ°æ–‡ä»¶
    private static void writeCallChainsToFile() {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(OUTPUT_FILE))) {
            Set<String> allCallers = new HashSet<>(callGraph.keySet());
            Set<String> allCallees = new HashSet<>();
            for (Set<String> callees : callGraph.values()) {
                allCallees.addAll(callees);
            }

            // æ ¹èŠ‚ç‚¹ï¼šæ–¹æ³•å‡ºç°åœ¨è°ƒç”¨è€…ï¼Œä½†ä¸åœ¨è¢«è°ƒç”¨è€…ä¸­
            Set<String> roots = new HashSet<>(allCallers);
            roots.removeAll(allCallees);

            if (roots.isEmpty()) {
                roots = allCallers; // å¯èƒ½æ‰€æœ‰æ–¹æ³•éƒ½æœ‰ç›¸äº’è°ƒç”¨å…³ç³»
            }

            for (String root : roots) {
                writeChain(writer, root, new HashSet<>(), 0);
            }

            System.out.println("è°ƒç”¨å…³ç³»å·²å†™å…¥: " + OUTPUT_FILE);
        } catch (IOException e) {
            System.err.println("å†™å…¥æ–‡ä»¶å¤±è´¥: " + e.getMessage());
        }
    }

    // é€’å½’å†™å…¥è°ƒç”¨é“¾
    private static void writeChain(BufferedWriter writer, String method, Set<String> visited, int depth) throws IOException {
        // å¤„ç†ç¼©è¿›
        for (int i = 0; i < depth; i++) {
            writer.write("    ");
        }
        writer.write(method + "\n");

        // é¿å…æ— é™å¾ªç¯
        if (visited.contains(method)) {
            return;
        }
        visited.add(method);

        Set<String> callees = callGraph.get(method);
        if (callees != null) {
            for (String callee : callees) {
                writeChain(writer, callee, new HashSet<>(visited), depth + 1);
            }
        }
    }
}







import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.symbolsolver.JavaSymbolSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;
import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;
import com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;

import java.io.File;
import java.io.FileInputStream;
import java.util.*;

public class CallGraphAnalyzer {

    // ä¿å­˜è°ƒç”¨å…³ç³»ï¼šcalleræ–¹æ³•çš„å…¨é™å®šç­¾å -> set(è¢«è°ƒç”¨æ–¹æ³•çš„å…¨é™å®šç­¾å)
    private static final Map<String, Set<String>> callGraph = new HashMap<>();
    // è¯·ä¿®æ”¹ä¸ºä½ å·¥ç¨‹å†…ä»£ç çš„åŒ…åå‰ç¼€ï¼Œå¦‚ "com.myproject"ï¼›ä¸ç¬¦åˆæ¡ä»¶çš„è°ƒç”¨ä¼šè¢«è¿‡æ»¤æ‰
    private static final String projectPackagePrefix = "com.myproject";

    public static void main(String[] args) throws Exception {
        // è®¾å®šæºç ç›®å½•ï¼Œæ›¿æ¢ä¸ºä½ å®é™…çš„æºç è·¯å¾„
        File srcDir = new File("your/project/src");
        CombinedTypeSolver combinedTypeSolver = new CombinedTypeSolver();
        combinedTypeSolver.add(new ReflectionTypeSolver());
        combinedTypeSolver.add(new JavaParserTypeSolver(srcDir));

        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(combinedTypeSolver);
        StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);

        // éå†æ•´ä¸ªå·¥ç¨‹çš„ .java æ–‡ä»¶ï¼Œæ„å»ºè°ƒç”¨å…³ç³»å›¾
        traverseDirectory(srcDir);

        // è¾“å‡ºè°ƒç”¨å…³ç³»ï¼šä»æ ¹èŠ‚ç‚¹å¼€å§‹å±‚çº§æ‰“å°è°ƒç”¨é“¾
        printCallChains();
    }

    // é€’å½’éå†ç›®å½•ä¸‹æ‰€æœ‰ Java æ–‡ä»¶
    private static void traverseDirectory(File directory) throws Exception {
        for (File file : Objects.requireNonNull(directory.listFiles())) {
            if (file.isDirectory()) {
                traverseDirectory(file);
            } else if (file.getName().endsWith(".java")) {
                processFile(file);
            }
        }
    }

    // è§£æå•ä¸ªæ–‡ä»¶ï¼Œæå–æ–¹æ³•è°ƒç”¨å…³ç³»
    private static void processFile(File file) {
        try (FileInputStream fis = new FileInputStream(file)) {
            CompilationUnit cu = StaticJavaParser.parse(fis);
            // éå†å½“å‰æ–‡ä»¶ä¸­çš„æ‰€æœ‰æ–¹æ³•å£°æ˜
            cu.findAll(MethodDeclaration.class).forEach(methodDeclaration -> {
                try {
                    // resolve() è·å–è°ƒç”¨è€…æ–¹æ³•çš„å…¨é™å®šç­¾å
                    String callerSignature = methodDeclaration.resolve().getQualifiedSignature();

                    // éå†è¯¥æ–¹æ³•ä½“å†…çš„æ‰€æœ‰æ–¹æ³•è°ƒç”¨è¡¨è¾¾å¼
                    methodDeclaration.findAll(MethodCallExpr.class).forEach(methodCall -> {
                        try {
                            ResolvedMethodDeclaration resolvedCallee = methodCall.resolve();
                            // è¿‡æ»¤æ‰å¤–éƒ¨è°ƒç”¨ï¼šåˆ¤æ–­è¢«è°ƒç”¨æ–¹æ³•çš„å£°æ˜ç±»æ˜¯å¦å±äºå·¥ç¨‹å†…ä»£ç 
                            ResolvedReferenceTypeDeclaration declaringType = resolvedCallee.declaringType();
                            String declaringTypeName = declaringType.getQualifiedName();
                            if (!declaringTypeName.startsWith(projectPackagePrefix)) {
                                // å¦‚æœä¸æ˜¯ä»¥é¡¹ç›®åŒ…åå‰ç¼€å¼€å§‹ï¼Œåˆ™è®¤ä¸ºæ˜¯å¤–éƒ¨è°ƒç”¨ï¼Œå¿½ç•¥æ‰
                                return;
                            }
                            String calleeSignature = resolvedCallee.getQualifiedSignature();
                            // å»ºç«‹è°ƒç”¨å…³ç³»ï¼šcaller -> callee
                            callGraph.computeIfAbsent(callerSignature, k -> new HashSet<>()).add(calleeSignature);
                        } catch (Exception e) {
                            // å¯¹äºæ— æ³•è§£æçš„è°ƒç”¨æ‰“å°æç¤ºï¼ˆä¾‹å¦‚åŠ¨æ€è°ƒç”¨ã€åå°„ç­‰æƒ…å†µï¼‰
                            System.err.println("æ— æ³•è§£æè°ƒç”¨: " + methodCall + " - " + e.getMessage());
                        }
                    });
                } catch (Exception e) {
                    System.err.println("æ— æ³•è§£ææ–¹æ³•å£°æ˜: " + methodDeclaration.getNameAsString() + " - " + e.getMessage());
                }
            });
        } catch (Exception e) {
            System.err.println("å¤„ç†æ–‡ä»¶å¤±è´¥: " + file.getAbsolutePath() + " - " + e.getMessage());
        }
    }

    // æ‰“å°è°ƒç”¨é“¾ï¼šå…ˆæ‰¾å‡ºæ ¹èŠ‚ç‚¹ï¼ˆæ²¡æœ‰ä½œä¸ºè¢«è°ƒç”¨è€…å‡ºç°çš„æ–¹æ³•ï¼‰ï¼Œç„¶åé€’å½’æ‰“å°æ•´ä¸ªè°ƒç”¨é“¾
    private static void printCallChains() {
        // æ”¶é›†æ‰€æœ‰è°ƒç”¨è€…å’Œè¢«è°ƒç”¨è€…
        Set<String> allCallers = new HashSet<>(callGraph.keySet());
        Set<String> allCallees = new HashSet<>();
        for (Set<String> callees : callGraph.values()) {
            allCallees.addAll(callees);
        }
        // æ ¹èŠ‚ç‚¹ï¼šåªå‡ºç°åœ¨è°ƒç”¨è€…ä¸­ï¼Œä½†ä¸ä½œä¸ºè¢«è°ƒç”¨è€…å‡ºç°
        Set<String> roots = new HashSet<>(allCallers);
        roots.removeAll(allCallees);

        // å¦‚æœæ²¡æœ‰æ ¹èŠ‚ç‚¹ï¼Œåˆ™æ‰€æœ‰èŠ‚ç‚¹å¯èƒ½éƒ½æœ‰å¾ªç¯è°ƒç”¨ï¼Œç›´æ¥å…¨éƒ¨è¾“å‡º
        if (roots.isEmpty()) {
            roots = allCallers;
        }

        for (String root : roots) {
            printChain(root, new HashSet<>(), 0);
        }
    }

    // é€’å½’æ‰“å°è°ƒç”¨é“¾ï¼Œvisited ç”¨äºé˜²æ­¢æ— é™å¾ªç¯
    private static void printChain(String method, Set<String> visited, int depth) {
        // ç¼©è¿›æ˜¾ç¤ºå±‚çº§
        for (int i = 0; i < depth; i++) {
            System.out.print("    ");
        }
        System.out.println(method);

        // å¦‚æœå·²ç»è®¿é—®è¿‡è¯¥èŠ‚ç‚¹ï¼Œåˆ™é¿å…å¾ªç¯ï¼ˆè¿™é‡Œæ¯æ¡é“¾å•ç‹¬å¤åˆ¶ visited é›†åˆï¼‰
        if (visited.contains(method)) {
            return;
        }
        visited.add(method);

        // é€’å½’éå†è¯¥æ–¹æ³•è°ƒç”¨çš„æ‰€æœ‰è¢«è°ƒç”¨æ–¹æ³•
        Set<String> callees = callGraph.get(method);
        if (callees != null) {
            for (String callee : callees) {
                printChain(callee, new HashSet<>(visited), depth + 1);
            }
        }
    }
}






import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.symbolsolver.JavaSymbolSolver;
import com.github.javaparser.symbolsolver.model.resolution.SymbolReference;
import com.github.javaparser.symbolsolver.model.resolution.TypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;
import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;

import java.io.File;
import java.io.FileInputStream;
import java.util.*;

public class CallGraphAnalyzer {

    // ä¿å­˜è°ƒç”¨å…³ç³»ï¼šcalleræ–¹æ³• -> set(è¢«è°ƒç”¨æ–¹æ³•)
    private static final Map<String, Set<String>> callGraph = new HashMap<>();

    public static void main(String[] args) throws Exception {
        // é…ç½®ç±»å‹æ±‚è§£å™¨ï¼ˆè¿™é‡Œå‡è®¾ä½ çš„æºç ç›®å½•ä¸º "your/project/src"ï¼‰
        File srcDir = new File("your/project/src"); // è¯·æ›¿æ¢ä¸ºå®é™…çš„æºç ç›®å½•
        TypeSolver reflectionTypeSolver = new ReflectionTypeSolver();
        TypeSolver javaParserTypeSolver = new JavaParserTypeSolver(srcDir);
        CombinedTypeSolver combinedTypeSolver = new CombinedTypeSolver(reflectionTypeSolver, javaParserTypeSolver);
        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(combinedTypeSolver);
        StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);

        // éå†æ•´ä¸ªå·¥ç¨‹ï¼ˆæºç ç›®å½•ä¸‹çš„æ‰€æœ‰ .java æ–‡ä»¶ï¼‰
        traverseDirectory(srcDir);

        // è¾“å‡ºè°ƒç”¨å…³ç³»
        for (Map.Entry<String, Set<String>> entry : callGraph.entrySet()) {
            String caller = entry.getKey();
            for (String callee : entry.getValue()) {
                System.out.println(caller + " -> " + callee);
            }
        }
    }

    // é€’å½’éå†ç›®å½•ä¸‹æ‰€æœ‰ Java æ–‡ä»¶
    private static void traverseDirectory(File directory) throws Exception {
        for (File file : Objects.requireNonNull(directory.listFiles())) {
            if (file.isDirectory()) {
                traverseDirectory(file);
            } else if (file.getName().endsWith(".java")) {
                processFile(file);
            }
        }
    }

    // è§£æå•ä¸ªæ–‡ä»¶ï¼Œæå–æ–¹æ³•è°ƒç”¨å…³ç³»
    private static void processFile(File file) {
        try (FileInputStream fis = new FileInputStream(file)) {
            CompilationUnit cu = StaticJavaParser.parse(fis);

            // éå†æ–‡ä»¶ä¸­çš„æ‰€æœ‰æ–¹æ³•å£°æ˜
            cu.findAll(MethodDeclaration.class).forEach(methodDeclaration -> {
                try {
                    // åˆ©ç”¨ç¬¦å·æ±‚è§£å™¨è§£ææ–¹æ³•å£°æ˜ï¼Œè·å–è°ƒç”¨è€…çš„å…¨é™å®šç­¾å
                    String callerSignature = methodDeclaration.resolve().getQualifiedSignature();

                    // åœ¨è¯¥æ–¹æ³•ä½“å†…æŸ¥æ‰¾æ‰€æœ‰æ–¹æ³•è°ƒç”¨è¡¨è¾¾å¼
                    methodDeclaration.findAll(MethodCallExpr.class).forEach(methodCall -> {
                        try {
                            ResolvedMethodDeclaration resolvedCallee = methodCall.resolve();
                            String calleeSignature = resolvedCallee.getQualifiedSignature();
                            // å»ºç«‹è°ƒç”¨å…³ç³»ï¼šcaller -> callee
                            callGraph.computeIfAbsent(callerSignature, k -> new HashSet<>()).add(calleeSignature);
                        } catch (Exception e) {
                            // æ— æ³•è§£æçš„è°ƒç”¨æ‰“å°æç¤ºï¼ˆå¯èƒ½æ¶‰åŠåŠ¨æ€è°ƒç”¨ã€åå°„ç­‰æƒ…å†µï¼‰
                            System.err.println("æ— æ³•è§£æè°ƒç”¨: " + methodCall + " - " + e.getMessage());
                        }
                    });
                } catch (Exception e) {
                    System.err.println("æ— æ³•è§£ææ–¹æ³•å£°æ˜: " + methodDeclaration.getNameAsString() + " - " + e.getMessage());
                }
            });
        } catch (Exception e) {
            System.err.println("å¤„ç†æ–‡ä»¶å¤±è´¥: " + file.getAbsolutePath() + " - " + e.getMessage());
        }
    }
}





import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.symbolsolver.JavaSymbolSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;
import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;

import java.io.File;
import java.io.FileInputStream;
import java.util.*;

public class CallGraphAnalyzer {

    // ä¿å­˜è°ƒç”¨å…³ç³»ï¼šcalleræ–¹æ³• -> set(è¢«è°ƒç”¨æ–¹æ³•)
    private static final Map<String, Set<String>> callGraph = new HashMap<>();

    public static void main(String[] args) throws Exception {
        // é…ç½®ç±»å‹æ±‚è§£å™¨ï¼ˆå‡è®¾ä½ çš„æºç ç›®å½•ä¸º "your/project/src"ï¼‰
        File srcDir = new File("your/project/src"); // è¯·æ›¿æ¢ä¸ºå®é™…çš„æºç è·¯å¾„
        CombinedTypeSolver combinedTypeSolver = new CombinedTypeSolver();
        combinedTypeSolver.add(new ReflectionTypeSolver());
        combinedTypeSolver.add(new JavaParserTypeSolver(srcDir));

        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(combinedTypeSolver);
        StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);

        // éå†æ•´ä¸ªå·¥ç¨‹çš„ .java æ–‡ä»¶
        traverseDirectory(srcDir);

        // è¾“å‡ºè°ƒç”¨å…³ç³»
        for (Map.Entry<String, Set<String>> entry : callGraph.entrySet()) {
            String caller = entry.getKey();
            for (String callee : entry.getValue()) {
                System.out.println(caller + " -> " + callee);
            }
        }
    }

    // é€’å½’éå†ç›®å½•ä¸‹æ‰€æœ‰ Java æ–‡ä»¶
    private static void traverseDirectory(File directory) throws Exception {
        for (File file : Objects.requireNonNull(directory.listFiles())) {
            if (file.isDirectory()) {
                traverseDirectory(file);
            } else if (file.getName().endsWith(".java")) {
                processFile(file);
            }
        }
    }

    // è§£æå•ä¸ªæ–‡ä»¶ï¼Œæå–æ–¹æ³•è°ƒç”¨å…³ç³»
    private static void processFile(File file) {
        try (FileInputStream fis = new FileInputStream(file)) {
            CompilationUnit cu = StaticJavaParser.parse(fis);

            // éå†å½“å‰æ–‡ä»¶ä¸­æ‰€æœ‰æ–¹æ³•å£°æ˜
            cu.findAll(MethodDeclaration.class).forEach(methodDeclaration -> {
                try {
                    // resolve() è·å–è°ƒç”¨è€…æ–¹æ³•çš„å…¨é™å®šç­¾å
                    String callerSignature = methodDeclaration.resolve().getQualifiedSignature();

                    // åœ¨è¯¥æ–¹æ³•ä½“å†…æŸ¥æ‰¾æ‰€æœ‰æ–¹æ³•è°ƒç”¨
                    methodDeclaration.findAll(MethodCallExpr.class).forEach(methodCall -> {
                        try {
                            ResolvedMethodDeclaration resolvedCallee = methodCall.resolve();
                            String calleeSignature = resolvedCallee.getQualifiedSignature();
                            // å»ºç«‹è°ƒç”¨å…³ç³»ï¼šcaller -> callee
                            callGraph.computeIfAbsent(callerSignature, k -> new HashSet<>()).add(calleeSignature);
                        } catch (Exception e) {
                            // æ— æ³•è§£æçš„è°ƒç”¨ï¼ˆå¯èƒ½æ¶‰åŠåå°„æˆ–åŠ¨æ€è°ƒç”¨ï¼‰æ—¶æ‰“å°æç¤º
                            System.err.println("æ— æ³•è§£æè°ƒç”¨: " + methodCall + " - " + e.getMessage());
                        }
                    });
                } catch (Exception e) {
                    System.err.println("æ— æ³•è§£ææ–¹æ³•å£°æ˜: " + methodDeclaration.getNameAsString() + " - " + e.getMessage());
                }
            });
        } catch (Exception e) {
            System.err.println("å¤„ç†æ–‡ä»¶å¤±è´¥: " + file.getAbsolutePath() + " - " + e.getMessage());
        }
    }
}
