import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.symbolsolver.JavaSymbolSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;
import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;
import com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;

import java.io.*;
import java.util.*;

public class CallGraphAnalyzer {

    private static final Map<String, Set<String>> callGraph = new HashMap<>();
    private static final String projectPackagePrefix = "com.myproject"; // 你的工程包名
    private static final String OUTPUT_FILE = "call_graph.txt"; // 输出文件路径
    private static CombinedTypeSolver combinedTypeSolver;

    public static void main(String[] args) throws Exception {
        File srcDir = new File("your/project/src"); // **确保这是你的 src 目录**

        // **确保 TypeSolver 解析整个项目**
        combinedTypeSolver = new CombinedTypeSolver();
        combinedTypeSolver.add(new ReflectionTypeSolver()); // 解析 JDK 类
        combinedTypeSolver.add(new JavaParserTypeSolver(srcDir)); // 解析 Java 源码

        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(combinedTypeSolver);
        StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);

        System.out.println("解析开始...");
        traverseDirectory(srcDir);
        System.out.println("解析完成！正在写入文件...");

        writeCallChainsToFile();
        System.out.println("调用关系已写入: " + OUTPUT_FILE);
    }

    // 遍历整个 Java 目录
    private static void traverseDirectory(File directory) throws Exception {
        for (File file : Objects.requireNonNull(directory.listFiles())) {
            if (file.isDirectory()) {
                traverseDirectory(file);
            } else if (file.getName().endsWith(".java")) {
                processFile(file);
            }
        }
    }

    // 解析 Java 文件，提取方法调用关系
    private static void processFile(File file) {
        System.out.println("正在解析文件: " + file.getName());
        try (FileInputStream fis = new FileInputStream(file)) {
            CompilationUnit cu = StaticJavaParser.parse(fis);
            cu.findAll(MethodDeclaration.class).forEach(methodDeclaration -> {
                try {
                    String callerSignature = methodDeclaration.resolve().getQualifiedSignature();

                    methodDeclaration.findAll(MethodCallExpr.class).forEach(methodCall -> {
                        try {
                            ResolvedMethodDeclaration resolvedCallee = methodCall.resolve();
                            ResolvedReferenceTypeDeclaration declaringType = resolvedCallee.declaringType();
                            String declaringTypeName = declaringType.getQualifiedName();

                            // **只解析工程内部的方法调用**
                            if (!declaringTypeName.startsWith(projectPackagePrefix)) {
                                return;
                            }

                            String calleeSignature = resolvedCallee.getQualifiedSignature();
                            callGraph.computeIfAbsent(callerSignature, k -> new HashSet<>()).add(calleeSignature);

                            System.out.println("✅ " + callerSignature + " 调用了 " + calleeSignature);
                        } catch (Exception e) {
                            System.err.println("❌ 方法解析失败: " + methodCall + " - " + e.getMessage());
                        }
                    });
                } catch (Exception e) {
                    System.err.println("❌ 方法声明解析失败: " + methodDeclaration.getNameAsString() + " - " + e.getMessage());
                }
            });
        } catch (Exception e) {
            System.err.println("❌ 处理失败: " + file.getAbsolutePath() + " - " + e.getMessage());
        }
    }

    // 写入调用链到文件
    private static void writeCallChainsToFile() {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(OUTPUT_FILE))) {
            for (String caller : callGraph.keySet()) {
                writer.write(caller + "\n");
                for (String callee : callGraph.get(caller)) {
                    writer.write("    → " + callee + "\n");
                }
            }
            System.out.println("✅ 调用关系已成功写入: " + OUTPUT_FILE);
        } catch (IOException e) {
            System.err.println("❌ 写入文件失败: " + e.getMessage());
        }
    }
}




import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.symbolsolver.JavaSymbolSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;
import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;
import com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;

import java.io.*;
import java.util.*;

public class CallGraphAnalyzer {

    private static final Map<String, Set<String>> callGraph = new HashMap<>();
    private static final String projectPackagePrefix = "com.myproject"; // 替换成你的包名
    private static final String OUTPUT_FILE = "call_graph.txt"; // 输出文件路径
    private static CombinedTypeSolver combinedTypeSolver;

    public static void main(String[] args) throws Exception {
        File srcDir = new File("your/project/src"); // 你的 Java 源码目录

        // 初始化 TypeSolver，确保可以解析整个项目代码
        combinedTypeSolver = new CombinedTypeSolver();
        combinedTypeSolver.add(new ReflectionTypeSolver()); // 解析 JDK 类
        combinedTypeSolver.add(new JavaParserTypeSolver(srcDir)); // 解析 Java 源码

        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(combinedTypeSolver);
        StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);

        // 解析整个工程的调用关系
        traverseDirectory(srcDir);

        // 将调用关系写入文件
        writeCallChainsToFile();
    }

    // 遍历所有 Java 文件
    private static void traverseDirectory(File directory) throws Exception {
        for (File file : Objects.requireNonNull(directory.listFiles())) {
            if (file.isDirectory()) {
                traverseDirectory(file);
            } else if (file.getName().endsWith(".java")) {
                processFile(file);
            }
        }
    }

    // 解析 Java 文件，提取方法调用关系
    private static void processFile(File file) {
        try (FileInputStream fis = new FileInputStream(file)) {
            CompilationUnit cu = StaticJavaParser.parse(fis);
            cu.findAll(MethodDeclaration.class).forEach(methodDeclaration -> {
                try {
                    String callerSignature = methodDeclaration.resolve().getQualifiedSignature();

                    // 解析方法体内所有方法调用
                    methodDeclaration.findAll(MethodCallExpr.class).forEach(methodCall -> {
                        try {
                            ResolvedMethodDeclaration resolvedCallee = methodCall.resolve();
                            ResolvedReferenceTypeDeclaration declaringType = resolvedCallee.declaringType();
                            String declaringTypeName = declaringType.getQualifiedName();

                            // 过滤非工程内部的方法
                            if (!declaringTypeName.startsWith(projectPackagePrefix)) {
                                return;
                            }

                            String calleeSignature = resolvedCallee.getQualifiedSignature();
                            callGraph.computeIfAbsent(callerSignature, k -> new HashSet<>()).add(calleeSignature);
                        } catch (Exception e) {
                            System.err.println("解析失败: " + methodCall + " - " + e.getMessage());
                        }
                    });
                } catch (Exception e) {
                    System.err.println("解析失败: " + methodDeclaration.getNameAsString() + " - " + e.getMessage());
                }
            });
        } catch (Exception e) {
            System.err.println("处理失败: " + file.getAbsolutePath() + " - " + e.getMessage());
        }
    }

    // 写入调用链到文件
    private static void writeCallChainsToFile() {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(OUTPUT_FILE))) {
            Set<String> allCallers = new HashSet<>(callGraph.keySet());
            Set<String> allCallees = new HashSet<>();
            for (Set<String> callees : callGraph.values()) {
                allCallees.addAll(callees);
            }

            // 找到根节点（只作为调用者，不是被调用者）
            Set<String> roots = new HashSet<>(allCallers);
            roots.removeAll(allCallees);

            if (roots.isEmpty()) {
                roots = allCallers; // 可能所有方法都有相互调用
            }

            for (String root : roots) {
                writeChain(writer, root, new HashSet<>(), 0);
            }

            System.out.println("调用关系已写入: " + OUTPUT_FILE);
        } catch (IOException e) {
            System.err.println("写入文件失败: " + e.getMessage());
        }
    }

    // 递归写入调用链
    private static void writeChain(BufferedWriter writer, String method, Set<String> visited, int depth) throws IOException {
        for (int i = 0; i < depth; i++) {
            writer.write("    ");
        }
        writer.write(method + "\n");

        if (visited.contains(method)) {
            return;
        }
        visited.add(method);

        Set<String> callees = callGraph.get(method);
        if (callees != null) {
            for (String callee : callees) {
                writeChain(writer, callee, new HashSet<>(visited), depth + 1);
            }
        }
    }
}





import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.symbolsolver.JavaSymbolSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;
import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;
import com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;

import java.io.*;
import java.util.*;

public class CallGraphAnalyzer {

    // 存储调用关系：caller 方法 -> 被调用方法集合
    private static final Map<String, Set<String>> callGraph = new HashMap<>();
    private static final String projectPackagePrefix = "com.myproject"; // 请修改为你工程的包名
    private static final String OUTPUT_FILE = "call_graph.txt"; // 输出文件路径

    public static void main(String[] args) throws Exception {
        File srcDir = new File("your/project/src"); // 替换成你的源码路径

        CombinedTypeSolver combinedTypeSolver = new CombinedTypeSolver();
        combinedTypeSolver.add(new ReflectionTypeSolver()); // 解析 JDK
        combinedTypeSolver.add(new JavaParserTypeSolver(srcDir)); // 解析 Java 源码

        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(combinedTypeSolver);
        StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);

        // 遍历整个工程的 .java 文件，解析方法调用关系
        traverseDirectory(srcDir);

        // 将调用链写入文件
        writeCallChainsToFile();
    }

    // 遍历所有 Java 文件
    private static void traverseDirectory(File directory) throws Exception {
        for (File file : Objects.requireNonNull(directory.listFiles())) {
            if (file.isDirectory()) {
                traverseDirectory(file);
            } else if (file.getName().endsWith(".java")) {
                processFile(file);
            }
        }
    }

    // 解析单个 Java 文件，提取方法调用关系
    private static void processFile(File file) {
        try (FileInputStream fis = new FileInputStream(file)) {
            CompilationUnit cu = StaticJavaParser.parse(fis);
            cu.findAll(MethodDeclaration.class).forEach(methodDeclaration -> {
                try {
                    String callerSignature = methodDeclaration.resolve().getQualifiedSignature();
                    methodDeclaration.findAll(MethodCallExpr.class).forEach(methodCall -> {
                        try {
                            ResolvedMethodDeclaration resolvedCallee = methodCall.resolve();
                            ResolvedReferenceTypeDeclaration declaringType = resolvedCallee.declaringType();
                            String declaringTypeName = declaringType.getQualifiedName();

                            // 只解析工程内部的方法调用
                            if (!declaringTypeName.startsWith(projectPackagePrefix)) {
                                return;
                            }

                            String calleeSignature = resolvedCallee.getQualifiedSignature();
                            callGraph.computeIfAbsent(callerSignature, k -> new HashSet<>()).add(calleeSignature);
                        } catch (Exception e) {
                            System.err.println("无法解析调用: " + methodCall + " - " + e.getMessage());
                        }
                    });
                } catch (Exception e) {
                    System.err.println("无法解析方法声明: " + methodDeclaration.getNameAsString() + " - " + e.getMessage());
                }
            });
        } catch (Exception e) {
            System.err.println("处理文件失败: " + file.getAbsolutePath() + " - " + e.getMessage());
        }
    }

    // 写入调用链到文件
    private static void writeCallChainsToFile() {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(OUTPUT_FILE))) {
            Set<String> allCallers = new HashSet<>(callGraph.keySet());
            Set<String> allCallees = new HashSet<>();
            for (Set<String> callees : callGraph.values()) {
                allCallees.addAll(callees);
            }

            // 根节点：方法出现在调用者，但不在被调用者中
            Set<String> roots = new HashSet<>(allCallers);
            roots.removeAll(allCallees);

            if (roots.isEmpty()) {
                roots = allCallers; // 可能所有方法都有相互调用关系
            }

            for (String root : roots) {
                writeChain(writer, root, new HashSet<>(), 0);
            }

            System.out.println("调用关系已写入: " + OUTPUT_FILE);
        } catch (IOException e) {
            System.err.println("写入文件失败: " + e.getMessage());
        }
    }

    // 递归写入调用链
    private static void writeChain(BufferedWriter writer, String method, Set<String> visited, int depth) throws IOException {
        // 处理缩进
        for (int i = 0; i < depth; i++) {
            writer.write("    ");
        }
        writer.write(method + "\n");

        // 避免无限循环
        if (visited.contains(method)) {
            return;
        }
        visited.add(method);

        Set<String> callees = callGraph.get(method);
        if (callees != null) {
            for (String callee : callees) {
                writeChain(writer, callee, new HashSet<>(visited), depth + 1);
            }
        }
    }
}







import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.symbolsolver.JavaSymbolSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;
import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;
import com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;

import java.io.File;
import java.io.FileInputStream;
import java.util.*;

public class CallGraphAnalyzer {

    // 保存调用关系：caller方法的全限定签名 -> set(被调用方法的全限定签名)
    private static final Map<String, Set<String>> callGraph = new HashMap<>();
    // 请修改为你工程内代码的包名前缀，如 "com.myproject"；不符合条件的调用会被过滤掉
    private static final String projectPackagePrefix = "com.myproject";

    public static void main(String[] args) throws Exception {
        // 设定源码目录，替换为你实际的源码路径
        File srcDir = new File("your/project/src");
        CombinedTypeSolver combinedTypeSolver = new CombinedTypeSolver();
        combinedTypeSolver.add(new ReflectionTypeSolver());
        combinedTypeSolver.add(new JavaParserTypeSolver(srcDir));

        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(combinedTypeSolver);
        StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);

        // 遍历整个工程的 .java 文件，构建调用关系图
        traverseDirectory(srcDir);

        // 输出调用关系：从根节点开始层级打印调用链
        printCallChains();
    }

    // 递归遍历目录下所有 Java 文件
    private static void traverseDirectory(File directory) throws Exception {
        for (File file : Objects.requireNonNull(directory.listFiles())) {
            if (file.isDirectory()) {
                traverseDirectory(file);
            } else if (file.getName().endsWith(".java")) {
                processFile(file);
            }
        }
    }

    // 解析单个文件，提取方法调用关系
    private static void processFile(File file) {
        try (FileInputStream fis = new FileInputStream(file)) {
            CompilationUnit cu = StaticJavaParser.parse(fis);
            // 遍历当前文件中的所有方法声明
            cu.findAll(MethodDeclaration.class).forEach(methodDeclaration -> {
                try {
                    // resolve() 获取调用者方法的全限定签名
                    String callerSignature = methodDeclaration.resolve().getQualifiedSignature();

                    // 遍历该方法体内的所有方法调用表达式
                    methodDeclaration.findAll(MethodCallExpr.class).forEach(methodCall -> {
                        try {
                            ResolvedMethodDeclaration resolvedCallee = methodCall.resolve();
                            // 过滤掉外部调用：判断被调用方法的声明类是否属于工程内代码
                            ResolvedReferenceTypeDeclaration declaringType = resolvedCallee.declaringType();
                            String declaringTypeName = declaringType.getQualifiedName();
                            if (!declaringTypeName.startsWith(projectPackagePrefix)) {
                                // 如果不是以项目包名前缀开始，则认为是外部调用，忽略掉
                                return;
                            }
                            String calleeSignature = resolvedCallee.getQualifiedSignature();
                            // 建立调用关系：caller -> callee
                            callGraph.computeIfAbsent(callerSignature, k -> new HashSet<>()).add(calleeSignature);
                        } catch (Exception e) {
                            // 对于无法解析的调用打印提示（例如动态调用、反射等情况）
                            System.err.println("无法解析调用: " + methodCall + " - " + e.getMessage());
                        }
                    });
                } catch (Exception e) {
                    System.err.println("无法解析方法声明: " + methodDeclaration.getNameAsString() + " - " + e.getMessage());
                }
            });
        } catch (Exception e) {
            System.err.println("处理文件失败: " + file.getAbsolutePath() + " - " + e.getMessage());
        }
    }

    // 打印调用链：先找出根节点（没有作为被调用者出现的方法），然后递归打印整个调用链
    private static void printCallChains() {
        // 收集所有调用者和被调用者
        Set<String> allCallers = new HashSet<>(callGraph.keySet());
        Set<String> allCallees = new HashSet<>();
        for (Set<String> callees : callGraph.values()) {
            allCallees.addAll(callees);
        }
        // 根节点：只出现在调用者中，但不作为被调用者出现
        Set<String> roots = new HashSet<>(allCallers);
        roots.removeAll(allCallees);

        // 如果没有根节点，则所有节点可能都有循环调用，直接全部输出
        if (roots.isEmpty()) {
            roots = allCallers;
        }

        for (String root : roots) {
            printChain(root, new HashSet<>(), 0);
        }
    }

    // 递归打印调用链，visited 用于防止无限循环
    private static void printChain(String method, Set<String> visited, int depth) {
        // 缩进显示层级
        for (int i = 0; i < depth; i++) {
            System.out.print("    ");
        }
        System.out.println(method);

        // 如果已经访问过该节点，则避免循环（这里每条链单独复制 visited 集合）
        if (visited.contains(method)) {
            return;
        }
        visited.add(method);

        // 递归遍历该方法调用的所有被调用方法
        Set<String> callees = callGraph.get(method);
        if (callees != null) {
            for (String callee : callees) {
                printChain(callee, new HashSet<>(visited), depth + 1);
            }
        }
    }
}






import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.symbolsolver.JavaSymbolSolver;
import com.github.javaparser.symbolsolver.model.resolution.SymbolReference;
import com.github.javaparser.symbolsolver.model.resolution.TypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;
import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;

import java.io.File;
import java.io.FileInputStream;
import java.util.*;

public class CallGraphAnalyzer {

    // 保存调用关系：caller方法 -> set(被调用方法)
    private static final Map<String, Set<String>> callGraph = new HashMap<>();

    public static void main(String[] args) throws Exception {
        // 配置类型求解器（这里假设你的源码目录为 "your/project/src"）
        File srcDir = new File("your/project/src"); // 请替换为实际的源码目录
        TypeSolver reflectionTypeSolver = new ReflectionTypeSolver();
        TypeSolver javaParserTypeSolver = new JavaParserTypeSolver(srcDir);
        CombinedTypeSolver combinedTypeSolver = new CombinedTypeSolver(reflectionTypeSolver, javaParserTypeSolver);
        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(combinedTypeSolver);
        StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);

        // 遍历整个工程（源码目录下的所有 .java 文件）
        traverseDirectory(srcDir);

        // 输出调用关系
        for (Map.Entry<String, Set<String>> entry : callGraph.entrySet()) {
            String caller = entry.getKey();
            for (String callee : entry.getValue()) {
                System.out.println(caller + " -> " + callee);
            }
        }
    }

    // 递归遍历目录下所有 Java 文件
    private static void traverseDirectory(File directory) throws Exception {
        for (File file : Objects.requireNonNull(directory.listFiles())) {
            if (file.isDirectory()) {
                traverseDirectory(file);
            } else if (file.getName().endsWith(".java")) {
                processFile(file);
            }
        }
    }

    // 解析单个文件，提取方法调用关系
    private static void processFile(File file) {
        try (FileInputStream fis = new FileInputStream(file)) {
            CompilationUnit cu = StaticJavaParser.parse(fis);

            // 遍历文件中的所有方法声明
            cu.findAll(MethodDeclaration.class).forEach(methodDeclaration -> {
                try {
                    // 利用符号求解器解析方法声明，获取调用者的全限定签名
                    String callerSignature = methodDeclaration.resolve().getQualifiedSignature();

                    // 在该方法体内查找所有方法调用表达式
                    methodDeclaration.findAll(MethodCallExpr.class).forEach(methodCall -> {
                        try {
                            ResolvedMethodDeclaration resolvedCallee = methodCall.resolve();
                            String calleeSignature = resolvedCallee.getQualifiedSignature();
                            // 建立调用关系：caller -> callee
                            callGraph.computeIfAbsent(callerSignature, k -> new HashSet<>()).add(calleeSignature);
                        } catch (Exception e) {
                            // 无法解析的调用打印提示（可能涉及动态调用、反射等情况）
                            System.err.println("无法解析调用: " + methodCall + " - " + e.getMessage());
                        }
                    });
                } catch (Exception e) {
                    System.err.println("无法解析方法声明: " + methodDeclaration.getNameAsString() + " - " + e.getMessage());
                }
            });
        } catch (Exception e) {
            System.err.println("处理文件失败: " + file.getAbsolutePath() + " - " + e.getMessage());
        }
    }
}





import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.symbolsolver.JavaSymbolSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;
import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;

import java.io.File;
import java.io.FileInputStream;
import java.util.*;

public class CallGraphAnalyzer {

    // 保存调用关系：caller方法 -> set(被调用方法)
    private static final Map<String, Set<String>> callGraph = new HashMap<>();

    public static void main(String[] args) throws Exception {
        // 配置类型求解器（假设你的源码目录为 "your/project/src"）
        File srcDir = new File("your/project/src"); // 请替换为实际的源码路径
        CombinedTypeSolver combinedTypeSolver = new CombinedTypeSolver();
        combinedTypeSolver.add(new ReflectionTypeSolver());
        combinedTypeSolver.add(new JavaParserTypeSolver(srcDir));

        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(combinedTypeSolver);
        StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);

        // 遍历整个工程的 .java 文件
        traverseDirectory(srcDir);

        // 输出调用关系
        for (Map.Entry<String, Set<String>> entry : callGraph.entrySet()) {
            String caller = entry.getKey();
            for (String callee : entry.getValue()) {
                System.out.println(caller + " -> " + callee);
            }
        }
    }

    // 递归遍历目录下所有 Java 文件
    private static void traverseDirectory(File directory) throws Exception {
        for (File file : Objects.requireNonNull(directory.listFiles())) {
            if (file.isDirectory()) {
                traverseDirectory(file);
            } else if (file.getName().endsWith(".java")) {
                processFile(file);
            }
        }
    }

    // 解析单个文件，提取方法调用关系
    private static void processFile(File file) {
        try (FileInputStream fis = new FileInputStream(file)) {
            CompilationUnit cu = StaticJavaParser.parse(fis);

            // 遍历当前文件中所有方法声明
            cu.findAll(MethodDeclaration.class).forEach(methodDeclaration -> {
                try {
                    // resolve() 获取调用者方法的全限定签名
                    String callerSignature = methodDeclaration.resolve().getQualifiedSignature();

                    // 在该方法体内查找所有方法调用
                    methodDeclaration.findAll(MethodCallExpr.class).forEach(methodCall -> {
                        try {
                            ResolvedMethodDeclaration resolvedCallee = methodCall.resolve();
                            String calleeSignature = resolvedCallee.getQualifiedSignature();
                            // 建立调用关系：caller -> callee
                            callGraph.computeIfAbsent(callerSignature, k -> new HashSet<>()).add(calleeSignature);
                        } catch (Exception e) {
                            // 无法解析的调用（可能涉及反射或动态调用）时打印提示
                            System.err.println("无法解析调用: " + methodCall + " - " + e.getMessage());
                        }
                    });
                } catch (Exception e) {
                    System.err.println("无法解析方法声明: " + methodDeclaration.getNameAsString() + " - " + e.getMessage());
                }
            });
        } catch (Exception e) {
            System.err.println("处理文件失败: " + file.getAbsolutePath() + " - " + e.getMessage());
        }
    }
}
